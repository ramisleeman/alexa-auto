From 4123d21773eea95d079f9d6a181a9d704549a50e Mon Sep 17 00:00:00 2001
From: Shotaro Uchida <fantom@xmaker.mx>
Date: Wed, 1 May 2019 19:23:36 +0000
Subject: [PATCH] Alexa Auto Specific Changes for v1.11 Device SDK For internal
 reference 3b4f4747267d5564f2a2832164f6d432785300da

---
 ACL/src/AVSConnectionManager.cpp              |   4 +-
 ACL/src/Transport/DownchannelHandler.cpp      |  22 +-
 ACL/src/Transport/HTTP2Transport.cpp          |   6 +-
 ACL/src/Transport/MessageRequestHandler.cpp   |  15 +-
 ACL/src/Transport/PingHandler.cpp             |  10 +-
 .../Transport/Common/MockHTTP2Connection.cpp  |   9 +-
 ACL/test/Transport/HTTP2TransportTest.cpp     |  19 +-
 ACL/test/Transport/MockHTTP2Connection.h      |   8 +-
 ADSL/include/ADSL/DirectiveProcessor.h        |  15 +
 ADSL/include/ADSL/DirectiveSequencer.h        |   6 +
 ADSL/src/DirectiveProcessor.cpp               |  30 +-
 ADSL/src/DirectiveSequencer.cpp               |  12 +
 ADSL/test/ADSL/MockDirectiveSequencer.h       |   6 +
 .../AVS/ExternalMediaPlayer/AdapterUtils.h    |  25 +-
 .../ExternalMediaAdapterConstants.h           |   9 +
 AVSCommon/AVS/src/BlockingPolicy.cpp          |   4 +-
 .../src/ExternalMediaPlayer/AdapterUtils.cpp  |  15 +-
 AVSCommon/CMakeLists.txt                      |   2 +
 .../CapabilitiesObserverInterface.h           |   4 +-
 .../DirectiveSequencerInterface.h             |   6 +
 .../ExternalMediaAdapterHandlerInterface.h    | 125 ++++
 .../ExternalMediaAdapterInterface.h           |  36 ++
 .../ExternalMediaPlayerInterface.h            |  24 +-
 .../HTTPContentFetcherInterface.h             | 129 +++-
 .../MessageRequestObserverInterface.h         |   4 +-
 .../SDKInterfaces/MockDirectiveSequencer.h    |   3 +
 .../AVSCommon/Utils/HTTP/HttpResponseCode.h   | 201 +++++++
 .../Utils/HTTP2/HTTP2MimeResponseDecoder.h    |   2 +-
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |   4 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |  83 +++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |  53 ++
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |  83 +++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |  53 ++
 .../Utils/LibcurlUtils/HttpResponseCodes.h    |  10 +-
 .../LibcurlUtils/LibCurlHttpContentFetcher.h  |  77 ++-
 .../Utils/Network/InternetConnectionMonitor.h |   5 +-
 .../Utils/PlaylistParser/PlaylistEntry.h      |  33 +-
 .../src/HTTP2/HTTP2MimeResponseDecoder.cpp    |   4 +-
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |   7 +-
 .../LibcurlUtils/CurlMultiHandleWrapper.cpp   |   2 -
 .../HTTPContentFetcherFactory.cpp             |  14 +-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     | 124 ++++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  | 124 ++++
 AVSCommon/Utils/src/LibcurlUtils/HttpPost.cpp |   2 +-
 AVSCommon/Utils/src/LibcurlUtils/HttpPut.cpp  |   2 +-
 .../LibCurlHttpContentFetcher.cpp             | 388 +++++++++---
 .../LibcurlUtils/LibcurlHTTP2Connection.cpp   |   1 +
 .../src/LibcurlUtils/LibcurlHTTP2Request.cpp  |   2 +-
 .../src/Network/InternetConnectionMonitor.cpp |  60 +-
 AVSCommon/Utils/test/MIMEParserTest.cpp       |  20 +-
 CMakeLists.txt                                |   4 +
 .../CapabilitiesDelegate.h                    |   9 +
 .../src/CapabilitiesDelegate.cpp              |  35 +-
 .../test/CapabilitiesDelegateTest.cpp         |   9 +-
 .../test/Common/TestableHttpPut.cpp           |   4 +-
 .../include/Alerts/AlertObserverInterface.h   |  23 +
 .../include/Alerts/AlertsCapabilityAgent.h    |  41 ++
 .../Alerts/src/AlertsCapabilityAgent.cpp      |  54 ++
 .../AudioPlayer/src/ProgressTimer.cpp         |  10 +-
 .../AudioPlayer/test/ProgressTimerTest.cpp    |  21 +-
 .../ExternalMediaPlayer/ExternalMediaPlayer.h | 100 ++++
 .../src/ExternalMediaPlayer.cpp               | 550 +++++++++++++++++-
 .../test/ExternalMediaPlayerTest.cpp          | 218 ++++++-
 .../Settings/include/Settings/Settings.h      |  11 +-
 CapabilityAgents/Settings/src/Settings.cpp    |  11 +-
 .../SpeechSynthesizer/SpeechSynthesizer.h     |  14 +-
 .../src/SpeechSynthesizer.cpp                 |  95 ++-
 .../test/SpeechSynthesizerTest.cpp            | 139 ++++-
 .../TemplateRuntime/src/TemplateRuntime.cpp   |  16 +-
 .../test/TemplateRuntimeTest.cpp              |   3 +
 .../test/MediaPlayerTest.cpp                  |  77 +--
 .../include/PlaylistParser/PlaylistUtils.h    |  13 +-
 .../UrlContentToAttachmentConverter.h         |  17 +-
 .../src/IterativePlaylistParser.cpp           |  67 +--
 PlaylistParser/src/PlaylistParser.cpp         | 106 ++--
 PlaylistParser/src/PlaylistUtils.cpp          | 136 +++--
 .../src/UrlContentToAttachmentConverter.cpp   |  78 ++-
 .../test/PlaylistParser/MockContentFetcher.h  | 111 ++--
 .../CBLAuthDelegate/src/CBLAuthDelegate.cpp   |   9 +-
 .../src/SQLiteCBLAuthDelegateStorage.cpp      |   4 +-
 80 files changed, 3336 insertions(+), 551 deletions(-)
 create mode 100644 AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/HTTP/HttpResponseCode.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp

diff --git a/ACL/src/AVSConnectionManager.cpp b/ACL/src/AVSConnectionManager.cpp
index 08ac422..01d35bf 100644
--- a/ACL/src/AVSConnectionManager.cpp
+++ b/ACL/src/AVSConnectionManager.cpp
@@ -119,7 +119,9 @@ void AVSConnectionManager::reconnect() {
 }
 
 void AVSConnectionManager::sendMessage(std::shared_ptr<avsCommon::avs::MessageRequest> request) {
-    m_messageRouter->sendMessage(request);
+    if (m_messageRouter != nullptr) {
+        m_messageRouter->sendMessage(request);
+    }
 }
 
 bool AVSConnectionManager::isConnected() const {
diff --git a/ACL/src/Transport/DownchannelHandler.cpp b/ACL/src/Transport/DownchannelHandler.cpp
index 1ac0056..f49be63 100644
--- a/ACL/src/Transport/DownchannelHandler.cpp
+++ b/ACL/src/Transport/DownchannelHandler.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -13,8 +13,8 @@
  * permissions and limitations under the License.
  */
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
 #include "ACL/Transport/DownchannelHandler.h"
@@ -24,6 +24,7 @@
 namespace alexaClientSDK {
 namespace acl {
 
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::http2;
 
 /// Downchannel URL
@@ -105,18 +106,23 @@ void DownchannelHandler::onActivity() {
 
 bool DownchannelHandler::onReceiveResponseCode(long responseCode) {
     ACSDK_DEBUG5(LX(__func__).d("responseCode", responseCode));
-    switch (responseCode) {
+    switch (intToHTTPResponseCode(responseCode)) {
         case HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED:
         case HTTPResponseCode::SUCCESS_NO_CONTENT:
-        case HTTPResponseCode::REDIRECTION_START_CODE:
-        case HTTPResponseCode::REDIRECTION_END_CODE:
-        case HTTPResponseCode::BAD_REQUEST:
-        case HTTPResponseCode::SERVER_INTERNAL_ERROR:
+        case HTTPResponseCode::SUCCESS_END_CODE:
+        case HTTPResponseCode::REDIRECTION_MULTIPLE_CHOICES:
+        case HTTPResponseCode::REDIRECTION_MOVED_PERMANENTLY:
+        case HTTPResponseCode::REDIRECTION_FOUND:
+        case HTTPResponseCode::REDIRECTION_SEE_ANOTHER:
+        case HTTPResponseCode::REDIRECTION_TEMPORARY_REDIRECT:
+        case HTTPResponseCode::REDIRECTION_PERMANENT_REDIRECT:
+        case HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST:
+        case HTTPResponseCode::SERVER_ERROR_INTERNAL:
             break;
         case HTTPResponseCode::SUCCESS_OK:
             m_context->onDownchannelConnected();
             break;
-        case HTTPResponseCode::FORBIDDEN:
+        case HTTPResponseCode::CLIENT_ERROR_FORBIDDEN:
             m_context->onForbidden(m_authToken);
             break;
     }
diff --git a/ACL/src/Transport/HTTP2Transport.cpp b/ACL/src/Transport/HTTP2Transport.cpp
index dd4e47d..e304c5a 100644
--- a/ACL/src/Transport/HTTP2Transport.cpp
+++ b/ACL/src/Transport/HTTP2Transport.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2016-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,9 +17,9 @@
 #include <functional>
 #include <random>
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeRequestEncoder.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/Timing/TimeUtils.h>
 #include <ACL/Transport/PostConnectInterface.h>
@@ -428,7 +428,7 @@ void HTTP2Transport::onForbidden(const std::string& authToken) {
 }
 
 std::shared_ptr<HTTP2RequestInterface> HTTP2Transport::createAndSendRequest(const HTTP2RequestConfig& cfg) {
-    ACSDK_DEBUG5(LX(__func__).d("type", cfg.getRequestType()).d("url", cfg.getUrl()));
+    ACSDK_DEBUG5(LX(__func__).d("type", cfg.getRequestType()).sensitive("url", cfg.getUrl()));
     return m_http2Connection->createAndSendRequest(cfg);
 }
 
diff --git a/ACL/src/Transport/MessageRequestHandler.cpp b/ACL/src/Transport/MessageRequestHandler.cpp
index a9b7158..49b9ff8 100644
--- a/ACL/src/Transport/MessageRequestHandler.cpp
+++ b/ACL/src/Transport/MessageRequestHandler.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,9 +17,9 @@
 #include <functional>
 #include <unordered_map>
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeRequestEncoder.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
 #include "ACL/Transport/HTTP2Transport.h"
@@ -31,6 +31,7 @@ namespace acl {
 
 using namespace avsCommon::avs::attachment;
 using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::http2;
 
 /// URL to send events to
@@ -246,7 +247,7 @@ bool MessageRequestHandler::onReceiveResponseCode(long responseCode) {
 
     reportMessageRequestAcknowledged();
 
-    if (HTTPResponseCode::FORBIDDEN == responseCode) {
+    if (HTTPResponseCode::CLIENT_ERROR_FORBIDDEN == intToHTTPResponseCode(responseCode)) {
         m_context->onForbidden(m_authToken);
     }
 
@@ -264,7 +265,7 @@ void MessageRequestHandler::onResponseFinished(HTTP2ResponseFinishedStatus statu
     reportMessageRequestAcknowledged();
     reportMessageRequestFinished();
 
-    if (m_responseCode != HTTPResponseCode::SUCCESS_OK && !nonMimeBody.empty()) {
+    if ((intToHTTPResponseCode(m_responseCode) != HTTPResponseCode::SUCCESS_OK) && !nonMimeBody.empty()) {
         m_messageRequest->exceptionReceived(nonMimeBody);
     }
 
@@ -289,9 +290,9 @@ void MessageRequestHandler::onResponseFinished(HTTP2ResponseFinishedStatus statu
         {HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED, MessageRequestObserverInterface::Status::INTERNAL_ERROR},
         {HTTPResponseCode::SUCCESS_OK, MessageRequestObserverInterface::Status::SUCCESS},
         {HTTPResponseCode::SUCCESS_NO_CONTENT, MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT},
-        {HTTPResponseCode::BAD_REQUEST, MessageRequestObserverInterface::Status::BAD_REQUEST},
-        {HTTPResponseCode::FORBIDDEN, MessageRequestObserverInterface::Status::INVALID_AUTH},
-        {HTTPResponseCode::SERVER_INTERNAL_ERROR, MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2}};
+        {HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST, MessageRequestObserverInterface::Status::BAD_REQUEST},
+        {HTTPResponseCode::CLIENT_ERROR_FORBIDDEN, MessageRequestObserverInterface::Status::INVALID_AUTH},
+        {HTTPResponseCode::SERVER_ERROR_INTERNAL, MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2}};
 
     auto result = MessageRequestObserverInterface::Status::INTERNAL_ERROR;
 
diff --git a/ACL/src/Transport/PingHandler.cpp b/ACL/src/Transport/PingHandler.cpp
index ee67335..ffbb5d3 100644
--- a/ACL/src/Transport/PingHandler.cpp
+++ b/ACL/src/Transport/PingHandler.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -13,8 +13,8 @@
  * permissions and limitations under the License.
  */
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 
 #include "ACL/Transport/HTTP2Transport.h"
 #include "ACL/Transport/PingHandler.h"
@@ -22,6 +22,7 @@
 namespace alexaClientSDK {
 namespace acl {
 
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::http2;
 
 /// URL to send pings to
@@ -90,7 +91,8 @@ void PingHandler::reportPingAcknowledged() {
     ACSDK_DEBUG5(LX(__func__));
     if (!m_wasPingAcknowledgedReported) {
         m_wasPingAcknowledgedReported = true;
-        m_context->onPingRequestAcknowledged(HTTPResponseCode::SUCCESS_NO_CONTENT == m_responseCode);
+        m_context->onPingRequestAcknowledged(
+            HTTPResponseCode::SUCCESS_NO_CONTENT == intToHTTPResponseCode(m_responseCode));
     }
 }
 
@@ -107,7 +109,7 @@ HTTP2SendDataResult PingHandler::onSendData(char* bytes, size_t size) {
 bool PingHandler::onReceiveResponseCode(long responseCode) {
     ACSDK_DEBUG5(LX(__func__).d("responseCode", responseCode));
 
-    if (HTTPResponseCode::FORBIDDEN == responseCode) {
+    if (HTTPResponseCode::CLIENT_ERROR_FORBIDDEN == intToHTTPResponseCode(responseCode)) {
         m_context->onForbidden(m_authToken);
     }
 
diff --git a/ACL/test/Transport/Common/MockHTTP2Connection.cpp b/ACL/test/Transport/Common/MockHTTP2Connection.cpp
index a38ac5b..03351a5 100644
--- a/ACL/test/Transport/Common/MockHTTP2Connection.cpp
+++ b/ACL/test/Transport/Common/MockHTTP2Connection.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -21,6 +21,8 @@ namespace utils {
 namespace http2 {
 namespace test {
 
+using namespace avsCommon::utils::http;
+    
 MockHTTP2Connection::MockHTTP2Connection(std::string dURL, std::string pingURL) :
         m_downchannelURL{dURL},
         m_pingURL{pingURL},
@@ -50,7 +52,7 @@ std::shared_ptr<HTTP2RequestInterface> MockHTTP2Connection::createAndSendRequest
         std::lock_guard<std::mutex> lock(m_postRequestMutex);
         m_postRequestQueue.push_back(request);
         if (m_postResponseCode != HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED) {
-            request->getSink()->onReceiveResponseCode(m_postResponseCode);
+            request->getSink()->onReceiveResponseCode(responseCodeToInt(m_postResponseCode));
         }
         if (m_postRequestQueue.size() > m_maxPostRequestsEnqueued) {
             m_maxPostRequestsEnqueued = m_postRequestQueue.size();
@@ -120,7 +122,8 @@ std::shared_ptr<MockHTTP2Request> MockHTTP2Connection::waitForPostRequest(const
     auto request = m_postRequestQueue.back();
 
     // Need to send 200 to MIME decoder in order for it parse the message.
-    request->getMimeDecoder()->onReceiveResponseCode(SUCCESS_OK);
+    request->getMimeDecoder()->onReceiveResponseCode(
+        static_cast<std::underlying_type<HTTPResponseCode>::type>(HTTPResponseCode::SUCCESS_OK));
 
     // Feed the header lines to the MIME decoder.
     for (auto headerLine : request->getSource()->getRequestHeaderLines()) {
diff --git a/ACL/test/Transport/HTTP2TransportTest.cpp b/ACL/test/Transport/HTTP2TransportTest.cpp
index 176fd0f..ebd10b9 100644
--- a/ACL/test/Transport/HTTP2TransportTest.cpp
+++ b/ACL/test/Transport/HTTP2TransportTest.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -28,8 +28,8 @@
 #include <AVSCommon/AVS/Attachment/AttachmentManager.h>
 #include <AVSCommon/AVS/Attachment/AttachmentUtils.h>
 #include <AVSCommon/Utils/PromiseFuturePair.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2RequestConfig.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 
 #include "MockAuthDelegate.h"
 #include "MockHTTP2Connection.h"
@@ -49,6 +49,7 @@ using namespace avsCommon::avs;
 using namespace avsCommon::avs::attachment;
 using namespace avsCommon::sdkInterfaces;
 using namespace avsCommon::utils;
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::http2;
 using namespace avsCommon::utils::http2::test;
 using namespace ::testing;
@@ -478,7 +479,7 @@ TEST_F(HTTP2TransportTest, retryOnDownchannelConnectionFailure) {
 
     // The Mock HTTP2Request replies to any downchannel request with a 500.
     ASSERT_TRUE(m_mockHttp2Connection->respondToDownchannelRequests(
-        static_cast<long>(SERVER_INTERNAL_ERROR), false, RESPONSE_TIMEOUT));
+        static_cast<long>(HTTPResponseCode::SERVER_ERROR_INTERNAL), false, RESPONSE_TIMEOUT));
 
     // Wait for a long time (up to 10 second), terminating the wait when the mock of HTTP2Connection receives a second
     // attempt to create a downchannel request.
@@ -738,7 +739,7 @@ TEST_F(HTTP2TransportTest, onSendCompletedNotification) {
                 HTTP2ResponseFinishedStatus::TIMEOUT,
                 MessageRequestObserverInterface::Status::TIMEDOUT)},
             {std::make_tuple(
-                HTTPResponseCode::BAD_REQUEST,
+                HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST,
                 static_cast<HTTP2ResponseFinishedStatus>(-1),
                 MessageRequestObserverInterface::Status::INTERNAL_ERROR)},
             {std::make_tuple(
@@ -762,15 +763,15 @@ TEST_F(HTTP2TransportTest, onSendCompletedNotification) {
                 HTTP2ResponseFinishedStatus::COMPLETE,
                 MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR)},
             {std::make_tuple(
-                HTTPResponseCode::BAD_REQUEST,
+                HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST,
                 HTTP2ResponseFinishedStatus::COMPLETE,
                 MessageRequestObserverInterface::Status::BAD_REQUEST)},
             {std::make_tuple(
-                HTTPResponseCode::FORBIDDEN,
+                HTTPResponseCode::CLIENT_ERROR_FORBIDDEN,
                 HTTP2ResponseFinishedStatus::COMPLETE,
                 MessageRequestObserverInterface::Status::INVALID_AUTH)},
             {std::make_tuple(
-                HTTPResponseCode::SERVER_INTERNAL_ERROR,
+                HTTPResponseCode::SERVER_ERROR_INTERNAL,
                 HTTP2ResponseFinishedStatus::COMPLETE,
                 MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2)},
             {std::make_tuple(
@@ -837,7 +838,7 @@ TEST_F(HTTP2TransportTest, onExceptionReceivedNon200Content) {
 
     auto request = m_mockHttp2Connection->waitForPostRequest(RESPONSE_TIMEOUT);
     ASSERT_NE(request, nullptr);
-    request->getSink()->onReceiveResponseCode(HTTPResponseCode::SERVER_INTERNAL_ERROR);
+    request->getSink()->onReceiveResponseCode(HTTPResponseCode::SERVER_ERROR_INTERNAL);
     request->getSink()->onReceiveData(NON_MIME_PAYLOAD.c_str(), NON_MIME_PAYLOAD.size());
     request->getSink()->onResponseFinished(HTTP2ResponseFinishedStatus::COMPLETE);
 
@@ -1078,7 +1079,7 @@ TEST_F(HTTP2TransportTest, tearDownPingFailure) {
         auto pingRequest = m_mockHttp2Connection->waitForPingRequest(RESPONSE_TIMEOUT);
         ASSERT_TRUE(pingRequest);
         m_mockHttp2Connection->dequePingRequest();
-        pingRequest->getSink()->onReceiveResponseCode(HTTPResponseCode::BAD_REQUEST);
+        pingRequest->getSink()->onReceiveResponseCode(HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST);
         pingRequest->getSink()->onResponseFinished(HTTP2ResponseFinishedStatus::COMPLETE);
     });
 
diff --git a/ACL/test/Transport/MockHTTP2Connection.h b/ACL/test/Transport/MockHTTP2Connection.h
index bb28f91..060f818 100644
--- a/ACL/test/Transport/MockHTTP2Connection.h
+++ b/ACL/test/Transport/MockHTTP2Connection.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -28,8 +28,8 @@
 
 #include <ACL/Transport/MessageConsumerInterface.h>
 #include <AVSCommon/Utils/PromiseFuturePair.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTP2/HTTP2ConnectionInterface.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 
 #include "MockHTTP2Request.h"
 
@@ -133,7 +133,7 @@ public:
      * @param responseCode The HTTP response code to reply to the request. If set to @c
      * HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED, a response code will not be sent.
      */
-    void setResponseToPOSTRequests(HTTPResponseCode responseCode);
+    void setResponseToPOSTRequests(http::HTTPResponseCode responseCode);
 
     /**
      * Retrieve the first HTTP2 request made on the downchannel.
@@ -253,7 +253,7 @@ private:
     PromiseFuturePair<void> m_receivedPauseOnSend;
 
     /// The response code to be replied for every POST request received.
-    HTTPResponseCode m_postResponseCode;
+    http::HTTPResponseCode m_postResponseCode;
 
     /// The maximum number of POST requests in the queue at any given time.
     std::size_t m_maxPostRequestsEnqueued;
diff --git a/ADSL/include/ADSL/DirectiveProcessor.h b/ADSL/include/ADSL/DirectiveProcessor.h
index dcd6c6c..0a1ab05 100644
--- a/ADSL/include/ADSL/DirectiveProcessor.h
+++ b/ADSL/include/ADSL/DirectiveProcessor.h
@@ -82,6 +82,12 @@ public:
      */
     void setDialogRequestId(const std::string& dialogRequestId);
 
+    std::string getCurrentDialogRequestId();
+
+    void setIsCurrentDialogRequestOnline(bool isOnline);
+
+    bool isCurrentDialogRequestOnline();
+    
     /**
      * Queue an @c AVSDirective for handling by whatever @c DirectiveHandler was registered to handle it.
      *
@@ -184,6 +190,12 @@ private:
      */
     void processingLoop();
 
+    void setIsCurrentDialogRequestOnlineLocked(bool isOnline);
+
+    bool isCurrentDialogRequestOnlineLocked();
+
+    std::string getCurrentDialogRequestIdLocked();
+
     /**
      * Process (cancel) all the items in @c m_cancelingQueue.
      * @note This method must only be called by threads that have acquired @c m_mutex.
@@ -285,6 +297,9 @@ private:
     /// Whether or not the @c DirectiveProcessor is enabled.
     bool m_isEnabled;
 
+    /// Whether the current dialog request is from AVS (online) or AHE (offline)
+    bool m_isDialogRequestOnline;
+
     /// The current @c dialogRequestId
     std::string m_dialogRequestId;
 
diff --git a/ADSL/include/ADSL/DirectiveSequencer.h b/ADSL/include/ADSL/DirectiveSequencer.h
index 995e7fc..72d3523 100644
--- a/ADSL/include/ADSL/DirectiveSequencer.h
+++ b/ADSL/include/ADSL/DirectiveSequencer.h
@@ -52,6 +52,12 @@ public:
 
     void setDialogRequestId(const std::string& dialogRequestId) override;
 
+    std::string getCurrentDialogRequestId() override;
+
+    void setIsCurrentDialogRequestOnline(bool isOnline) override;
+
+    bool isCurrentDialogRequestOnline() override;
+
     bool onDirective(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
 
     void disable() override;
diff --git a/ADSL/src/DirectiveProcessor.cpp b/ADSL/src/DirectiveProcessor.cpp
index 41df447..9afe33c 100644
--- a/ADSL/src/DirectiveProcessor.cpp
+++ b/ADSL/src/DirectiveProcessor.cpp
@@ -47,7 +47,8 @@ std::unordered_map<DirectiveProcessor::ProcessorHandle, DirectiveProcessor*> Dir
 DirectiveProcessor::DirectiveProcessor(DirectiveRouter* directiveRouter) :
         m_directiveRouter{directiveRouter},
         m_isShuttingDown{false},
-        m_isEnabled{true} {
+        m_isEnabled{true},
+        m_isDialogRequestOnline{true} {
     std::lock_guard<std::mutex> lock(m_handleMapMutex);
     m_handle = ++m_nextProcessorHandle;
     m_handleMap[m_handle] = this;
@@ -63,6 +64,21 @@ void DirectiveProcessor::setDialogRequestId(const std::string& dialogRequestId)
     setDialogRequestIdLocked(dialogRequestId);
 }
 
+std::string DirectiveProcessor::getCurrentDialogRequestId() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    return getCurrentDialogRequestIdLocked();
+}
+
+void DirectiveProcessor::setIsCurrentDialogRequestOnline(bool isOnline) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    setIsCurrentDialogRequestOnlineLocked(isOnline);
+}
+
+bool DirectiveProcessor::isCurrentDialogRequestOnline() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    return isCurrentDialogRequestOnlineLocked();
+}
+
 bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
@@ -129,6 +145,18 @@ bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     return true;
 }
 
+std::string DirectiveProcessor::getCurrentDialogRequestIdLocked() {
+    return m_dialogRequestId;
+}
+
+void DirectiveProcessor::setIsCurrentDialogRequestOnlineLocked(bool isOnline) {
+    m_isDialogRequestOnline = isOnline;
+}
+
+bool DirectiveProcessor::isCurrentDialogRequestOnlineLocked() {
+    return m_isDialogRequestOnline;
+}
+
 void DirectiveProcessor::shutdown() {
     {
         std::lock_guard<std::mutex> lock(m_handleMapMutex);
diff --git a/ADSL/src/DirectiveSequencer.cpp b/ADSL/src/DirectiveSequencer.cpp
index 473c25a..c0c58a0 100644
--- a/ADSL/src/DirectiveSequencer.cpp
+++ b/ADSL/src/DirectiveSequencer.cpp
@@ -62,6 +62,18 @@ void DirectiveSequencer::setDialogRequestId(const std::string& dialogRequestId)
     m_directiveProcessor->setDialogRequestId(dialogRequestId);
 }
 
+std::string DirectiveSequencer::getCurrentDialogRequestId() {
+    return m_directiveProcessor->getCurrentDialogRequestId();
+}
+
+bool DirectiveSequencer::isCurrentDialogRequestOnline() {
+    return m_directiveProcessor->isCurrentDialogRequestOnline();
+}
+
+void DirectiveSequencer::setIsCurrentDialogRequestOnline(bool isOnline) {
+    m_directiveProcessor->setIsCurrentDialogRequestOnline(isOnline);
+}
+
 bool DirectiveSequencer::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
diff --git a/ADSL/test/ADSL/MockDirectiveSequencer.h b/ADSL/test/ADSL/MockDirectiveSequencer.h
index 69c6645..ffdd95a 100644
--- a/ADSL/test/ADSL/MockDirectiveSequencer.h
+++ b/ADSL/test/ADSL/MockDirectiveSequencer.h
@@ -45,6 +45,12 @@ public:
 
     MOCK_METHOD1(setDialogRequestId, void(const std::string& dialogRequestId));
 
+    MOCK_METHOD0(getCurrentDialogRequestId, std::string());
+
+    MOCK_METHOD0(isCurrentDialogRequestOnline, bool());
+    
+    MOCK_METHOD1(setIsCurrentDialogRequestOnline, void(bool));
+
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
 
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h
index cd5672e..8b7c62c 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/AdapterUtils.h
@@ -33,7 +33,7 @@ namespace externalMediaPlayer {
 /// Enumeration class for events sent by adapters to AVS.
 enum class AdapterEvent {
     /// ChangeReport event sent after adapter's initialization succeeds/fails.
-    CHANGE_REPORT,
+    CHANGE_REPORT, // Note: not in ExternalMediaPlayer 1.1
 
     /// Event to request token from third party.
     REQUEST_TOKEN,
@@ -48,7 +48,19 @@ enum class AdapterEvent {
     PLAYER_EVENT,
 
     /// PlayerErrorEvent to report all errors from the adapters.
-    PLAYER_ERROR_EVENT
+    PLAYER_ERROR_EVENT, // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /// PlayerError event to report all errors from the adapters.
+    PLAYER_ERROR,
+
+    /// ReportDiscoveredPlayers event notifies the cloud of discovered players to be authorized.
+    REPORT_DISCOVERED_PLAYERS,
+
+    /// AuthorizationComplete event notifies the cloud of players which were authorized (and de-authorized).
+    AUTHORIZATION_COMPLETE
+
+#endif
 };
 
 /// Table with the retry times on subsequent retries for session management (token fetch/changeReport send).
@@ -58,12 +70,17 @@ extern const std::vector<int> SESSION_RETRY_TABLE;
 extern avsCommon::utils::RetryTimer SESSION_RETRY_TIMER;
 
 // The NamespaceAndName for events sent from the adapter to AVS.
-extern const avsCommon::avs::NamespaceAndName CHANGE_REPORT;
+extern const avsCommon::avs::NamespaceAndName CHANGE_REPORT; // Note: not in ExternalMediaPlayer 1.1
 extern const avsCommon::avs::NamespaceAndName REQUEST_TOKEN;
 extern const avsCommon::avs::NamespaceAndName LOGIN;
 extern const avsCommon::avs::NamespaceAndName LOGOUT;
 extern const avsCommon::avs::NamespaceAndName PLAYER_EVENT;
-extern const avsCommon::avs::NamespaceAndName PLAYER_ERROR_EVENT;
+extern const avsCommon::avs::NamespaceAndName PLAYER_ERROR_EVENT; // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+#ifdef EXTERNALMEDIAPLAYER_1_1
+extern const avsCommon::avs::NamespaceAndName PLAYER_ERROR; // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+extern const avsCommon::avs::NamespaceAndName REPORT_DISCOVERED_PLAYERS;
+extern const avsCommon::avs::NamespaceAndName AUTHORIZATION_COMPLETE;
+#endif
 
 /**
  * Method to iterate over a vector of supported operation in playback state and convert to JSON.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h
index e5a4ee0..1ed8f86 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/ExternalMediaPlayer/ExternalMediaAdapterConstants.h
@@ -31,6 +31,15 @@ const char USERNAME[] = "username";
 const char IS_GUEST[] = "isGuest";
 const char LAUNCHED[] = "launched";
 const char ACTIVE[] = "active";
+#ifdef EXTERNALMEDIAPLAYER_1_1
+const char SPI_VERSION[] = "spiVersion";
+const char SPI_VERSION_DEFAULT[] = "1.0";
+const char PLAYER_COOKIE[] = "playerCookie";
+const char SKILL_TOKEN[] = "skillToken";
+const char PLAYBACK_SESSION_ID[] = "playbackSessionId";
+const char AGENT[] = "agent";
+const char AGENT_DEFAULT[] = "RUHAV8PRLD";
+#endif
 
 // The key values used in the context payload from External Media Player to AVS.
 const char STATE[] = "state";
diff --git a/AVSCommon/AVS/src/BlockingPolicy.cpp b/AVSCommon/AVS/src/BlockingPolicy.cpp
index e86209c..dc2926e 100644
--- a/AVSCommon/AVS/src/BlockingPolicy.cpp
+++ b/AVSCommon/AVS/src/BlockingPolicy.cpp
@@ -30,10 +30,10 @@ using namespace avsCommon::avs;
 using namespace avsCommon::utils::json;
 
 /// Flag indicating @c AUDIO medium is used.
-static const BlockingPolicy::Mediums MEDIUM_FLAG_AUDIO{1};
+static const long MEDIUM_FLAG_AUDIO = 1;
 
 /// Flag indicating @c VISUAL medium is used.
-static const BlockingPolicy::Mediums MEDIUM_FLAG_VISUAL{2};
+static const long MEDIUM_FLAG_VISUAL = 2;
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("BlockingPolicy");
diff --git a/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp b/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
index 169dda8..8eca67a 100644
--- a/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
+++ b/AVSCommon/AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
@@ -45,12 +45,17 @@ const std::vector<int> SESSION_RETRY_TABLE = {
 
 avsCommon::utils::RetryTimer SESSION_RETRY_TIMER(SESSION_RETRY_TABLE);
 
-const NamespaceAndName CHANGE_REPORT("Alexa", "ChangeReport");
+const NamespaceAndName CHANGE_REPORT("Alexa", "ChangeReport"); // Note: not in ExternalMediaPlayer 1.1
 const NamespaceAndName REQUEST_TOKEN("ExternalMediaPlayer", "RequestToken");
 const NamespaceAndName LOGIN("ExternalMediaPlayer", "Login");
 const NamespaceAndName LOGOUT("ExternalMediaPlayer", "Logout");
 const NamespaceAndName PLAYER_EVENT("ExternalMediaPlayer", "PlayerEvent");
-const NamespaceAndName PLAYER_ERROR_EVENT("ExternalMediaPlayer", "PlayerError");
+const NamespaceAndName PLAYER_ERROR_EVENT("ExternalMediaPlayer", "PlayerError"); // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+#ifdef EXTERNALMEDIAPLAYER_1_1
+const NamespaceAndName PLAYER_ERROR("ExternalMediaPlayer", "PlayerError"); // Note: rename PLAYER_ERROR in ExternalMediaPlayer 1.1
+const NamespaceAndName REPORT_DISCOVERED_PLAYERS("ExternalMediaPlayer", "ReportDiscoveredPlayers");
+const NamespaceAndName AUTHORIZATION_COMPLETE("ExternalMediaPlayer", "AuthorizationComplete");
+#endif
 
 /// The default state of a player.
 const char DEFAULT_STATE[] = "IDLE";
@@ -128,6 +133,12 @@ rapidjson::Value buildSessionState(
     playerJson.AddMember(IS_GUEST, sessionState.isGuest, allocator);
     playerJson.AddMember(LAUNCHED, sessionState.launched, allocator);
     playerJson.AddMember(ACTIVE, sessionState.active, allocator);
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    playerJson.AddMember(SPI_VERSION, sessionState.spiVersion, allocator);
+    playerJson.AddMember(PLAYER_COOKIE, sessionState.playerCookie, allocator);
+    playerJson.AddMember(SKILL_TOKEN, sessionState.skillToken, allocator);
+    playerJson.AddMember(PLAYBACK_SESSION_ID, sessionState.playbackSessionId, allocator);
+#endif
 
     return playerJson;
 }
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index 4ed463f..01ab6bc 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -49,6 +49,8 @@ add_library(AVSCommon SHARED
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CapabilitiesObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CapabilitiesObserverInterface.h
index 4df8d39..59e0ab1 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CapabilitiesObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CapabilitiesObserverInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -113,7 +113,7 @@ inline std::ostream& operator<<(std::ostream& stream, const CapabilitiesObserver
         case CapabilitiesObserverInterface::Error::SERVER_INTERNAL_ERROR:
             return stream << "SERVER_INTERNAL_ERROR";
         case CapabilitiesObserverInterface::Error::BAD_REQUEST:
-            return stream << "BAD_REQUEST";
+            return stream << "CLIENT_ERROR_BAD_REQUEST";
     }
     return stream << "Unknown CapabilitiesObserverInterface::Error!: " << error;
 }
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
index 5086e5d..f5093b8 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
@@ -92,6 +92,12 @@ public:
      */
     virtual void setDialogRequestId(const std::string& dialogRequestId) = 0;
 
+    virtual std::string getCurrentDialogRequestId() = 0;
+
+    virtual void setIsCurrentDialogRequestOnline(bool isOnline) = 0;
+
+    virtual bool isCurrentDialogRequestOnline() = 0;
+
     /**
      * Sequence the handling of an @c AVSDirective.  The actual handling is done by whichever @c DirectiveHandler
      * is associated with the @c AVSDirective's (namespace, name) pair.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h
new file mode 100644
index 0000000..d48fc1e
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAADAPTERHANDLERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAADAPTERHANDLERINTERFACE_H_
+
+#include <chrono>
+#include <string>
+
+#include "AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+
+/**
+ * The ExternalMediaAdapterHandlerInterface class provides generic ExternalMediaPlayer 1.1 Interface support
+ * for extending functionality to custom handlers for managing multi player adapters as required by MACC.
+ * Note: This interface may eventually be replaced with integrated support for multi player adapters.
+ */
+class ExternalMediaAdapterHandlerInterface {
+public:
+    /**
+     * Destructor
+     */
+    virtual ~ExternalMediaAdapterHandlerInterface() = default;
+
+    /**
+     * Method to handle the ExternalMediaPlayer AuthorizeDiscoveredPlayers directive.
+     *
+     * @param payload The AuthorizeDiscoveredPlayers directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void authorizeDiscoveredPlayers(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the ExternalMediaPlayer Login directive.
+     *
+     * @param payload The Login directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void login(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the ExternalMediaPlayer Logout directive.
+     *
+     * @param payload The Logout directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void logout(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the ExternalMediaPlayer Play directive.
+     *
+     * @param payload The Play directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void play(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the Alexa.PlaybackController Play/Pause/Next/Previous/StartOver/Rewind/FastForward directives.
+     *
+     * @param payload The Play/Pause/Next/Previous/StartOver/Rewind/FastForward directive payload.
+     * @param requestType The external media player request type.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void playControl(const std::string& payload, alexaClientSDK::avsCommon::sdkInterfaces::externalMediaPlayer::RequestType requestType) = 0;
+
+    /**
+     * Method to handle the Alexa.PlaybackController Play/Pause/Next/Previous/StartOver/Rewind/FastForward directives for a designated player (i.e. the player in focus).
+     *
+     * @param payload The Play/Pause/Next/Previous/StartOver/Rewind/FastForward directive payload.
+     * @param requestType The external media player request type.
+     *
+     * @note Handles PlaybackHandlerInterface onTogglePressed() and onButtonPressed() notifications for the player in focus.
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void playControlForPlayer(const std::string& playerId, alexaClientSDK::avsCommon::sdkInterfaces::externalMediaPlayer::RequestType requestType) = 0;
+
+    /**
+     * Method to handle the Alexa.SeekController SetSeekPosition directive.
+     *
+     * @param payload The SetSeekPosition directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void seek(const std::string& payload) = 0;
+
+    /**
+     * Method to handle the Alexa.SeekController AdjustSeekPosition directive.
+     *
+     * @param payload The AdjustSeekPosition directive payload.
+     *
+     * @note With multiple adapter handlers, playerId can belong to another adapter handler.
+     */
+    virtual void adjustSeek(const std::string& payload) = 0;
+
+    /**
+     * Method to get adapter state for each of the handled players.
+     */
+    virtual std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> getAdapterStates() = 0;
+};
+
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAADAPTERHANDLERINTERFACE_H_
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h
index 152a626..77273b2 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaAdapterInterface.h
@@ -267,6 +267,21 @@ struct AdapterSessionState {
      */
     bool active;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /// The service provider interface (SPI) version.
+    std::string spiVersion;
+
+    /// The playerCookie to select version-specific content or actions.
+    std::string playerCookie;
+
+    /// An opaque token for the domain or skill that is presently associated with this player.
+    std::string skillToken;
+
+    /// A universally unique identifier (UUID) generated to the RFC 4122 specification.
+    std::string playbackSessionId;
+
+#endif
+
     /**
      * The accessToken used to login a user. The access token may also be used as a bearer token if the adapter
      * makes an authenticated Web API to the music provider.
@@ -425,6 +440,26 @@ public:
      */
     virtual void handleLogout() = 0;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Method to allow a user to initiate play from a third party music service provider based on a play context.
+     *
+     * @param playContextToken Play context {Track/playlist/album/artist/station/podcast} identifier.
+     * @param index The index of the media item in the container, if the container is indexable.
+     * @param offset The offset position within media item, in milliseconds.
+     * @param skillToken An opaque token for the domain or skill that is presently associated with this player.
+     * @param playbackSessionId A universally unique identifier (UUID) generated to the RFC 4122 specification.
+     * @param navigation Communicates desired visual display behavior for the app associated with playback.
+     * @param preload If true, this Play directive is intended to preload the identified content only but not begin playback.
+     */
+    virtual void handlePlay(std::string& playContextToken,
+                            int64_t index,
+                            std::chrono::milliseconds offset,
+                            std::string& skillToken,
+                            std::string& playbackSessionId,
+                            std::string& navigation, // DEFAULT, NONE, FOREGROUND
+                            bool preload) = 0;
+#else
     /**
      * Method to allow a user to initiate play from a third party music service provider based on a play context.
      *
@@ -433,6 +468,7 @@ public:
      * @param offset The offset position within media item, in milliseconds.
      */
     virtual void handlePlay(std::string& playContextToken, int64_t index, std::chrono::milliseconds offset) = 0;
+#endif
 
     /**
      * Method to initiate the different types of play control like PLAY/PAUSE/RESUME/NEXT/...
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h
index 4b67622..fe9c174 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ExternalMediaPlayerInterface.h
@@ -16,6 +16,9 @@
 #ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAPLAYERINTERFACE_H_
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_EXTERNALMEDIAPLAYERINTERFACE_H_
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+#include <AVSCommon/AVS/PlayerActivity.h>
+#endif
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
@@ -30,7 +33,8 @@ namespace sdkInterfaces {
 
 /**
  * This class provides an interface to the @c ExternalMediaPlayer.
- * Currently it provides an interface for adapters to set the player in focus when they acquire focus.
+ * Currently it provides an interface for adapters to set the current activity
+ * and set the player in focus when they acquire focus.
  */
 class ExternalMediaPlayerInterface {
 public:
@@ -39,6 +43,24 @@ public:
      */
     virtual ~ExternalMediaPlayerInterface() = default;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Method to set the current activity for the player in focus.
+     *
+     * @param currentActivity The current activity of the player.
+     */
+    virtual void setCurrentActivity(const avsCommon::avs::PlayerActivity currentActivity) = 0;
+
+    /**
+     * Method to set the player in focus after an adapter has acquired the channel.
+     *
+     * @param playerInFocus The business name of the adapter that has currently acquired focus.
+     * @param focusAcquire If @c true, acquire the channel and manage the focus state.
+     * If @c false release the channel when the player is the player in focus.
+     */
+    virtual void setPlayerInFocus(const std::string& playerInFocus, bool focusAcquire) = 0;
+#endif
+
     /**
      * Method to set the player in focus after an adapter has acquired the channel.
      *
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/HTTPContentFetcherInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/HTTPContentFetcherInterface.h
index 874fe90..7725c35 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/HTTPContentFetcherInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/HTTPContentFetcherInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 #include <memory>
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/HTTPContent.h>
 #include <AVSCommon/Utils/SDKVersion.h>
 
@@ -34,27 +35,106 @@ public:
     enum class FetchOptions {
         /// Retrieves the content type part of the HTTP header.
         CONTENT_TYPE,
-
         /// Retrieves the entire body of the remote location.
         ENTIRE_BODY
     };
 
+    /// The state of payload fetching
+    enum class State {
+        /// Initialized but nothing was downloaded yet.
+        INITIALIZED,
+        /// Currently fetching the header
+        FETCHING_HEADER,
+        /// Done fetching the header. Ready to start fetching the body.
+        HEADER_DONE,
+        /// Currently fetching the body.
+        FETCHING_BODY,
+        /// Done fetching the body. At this point the content fetcher can only be used to read the headers.
+        BODY_DONE,
+        /// Some error happened at any stage and the content fetcher cannot be used anymore.
+        ERROR
+    };
+
+    /**
+     * A struct that represents the header that was retrieved from the HTTP connection. Objects that receive this
+     * struct are responsible for checking if the successful field is true before reading the other fields.
+     */
+    struct Header {
+        /// If @c false, there was an error retrieving the header. For instance, the content fetcher may have reached
+        /// a timeout waiting for the server. If this field's value is @c false, all other field values should be
+        /// ignored.
+        bool successful;
+        /// The HTTP status code received.
+        avsCommon::utils::http::HTTPResponseCode responseCode;
+        /// The value of the Content-Type HTTP header.
+        std::string contentType;
+        /// The value of the Content-Length HTTP header.
+        ssize_t contentLength;
+
+        Header() :
+                successful(false),
+                responseCode(avsCommon::utils::http::HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED),
+                contentType(""),
+                contentLength(0) {
+        }
+    };
+
     /**
      * Destructor.
      */
     virtual ~HTTPContentFetcherInterface() = default;
 
+    /**
+     * The current content fetching state. In particular, a caller of @c getBody, an asynchronous function, can use this
+     * method to monitor the download progress.
+     *
+     * @return The current content fetching state.
+     */
+    virtual State getState() = 0;
+
+    /**
+     * Gets the URL associated with this content fetcher
+     *
+     * @return The content fetcher URL
+     */
+    virtual std::string getUrl() const = 0;
+
+    /**
+     * Waits until the header was fetched successfully. If any problem happened during header, returns @c false. After
+     * the header was already fetched, this method can be called multiple times and will return immediately.
+     *
+     * @param shouldShutdown A pointer to allow for the caller to asynchronously cancel the wait, if needed. this
+     * argument is optional. If it is a null pointer, the function will ignore it.
+     * @return The header struct. It is the caller's responsibility to check the struct to see if the header was
+     * retrieved successfully.
+     */
+    virtual Header getHeader(std::atomic<bool>* shouldShutdown) = 0;
+
+    /**
+     * Retrieves the body after the header was received. This method is asynchronous and the caller can monitor the
+     * download progress using the @c getState method.
+     *
+     * @param writer The writer to write the payload.
+     * @return @c true if the call is successful.
+     */
+    virtual bool getBody(std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer) = 0;
+
+    /**
+     * Shuts down the content fetcher.
+     */
+    virtual void shutdown() = 0;
+
     /**
      * This function retrieves content from a remote location. No thread safety is guaranteed.
      *
      * @param option Flag indicating desired content.
      * @param writer An optional writer parameter to be used when writing to an external stream.
      * @param customHeaders An optional list of headers to be attached to the request.
-     * @return A new @c HTTPContent object or @c nullptr if a failure occured.
+     * @return A new @c HTTPContent object or @c nullptr if a failure occurred.
      */
     virtual std::unique_ptr<avsCommon::utils::HTTPContent> getContent(
         FetchOptions option,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer = nullptr,
+        std::unique_ptr<avsCommon::avs::attachment::AttachmentWriter> writer = nullptr,
         const std::vector<std::string>& customHeaders = std::vector<std::string>()) = 0;
 
     /**
@@ -62,13 +142,50 @@ public:
      *
      * @return User-Agent string to be used in HTTP requests.
      */
-    inline static std::string getUserAgent();
+    static std::string getUserAgent();
+
+    /**
+     * Produces the string representation of the state enum values.
+     * @param state The state enum value.
+     * @return Its string representation.
+     */
+    static std::string stateToString(State state);
 };
 
-std::string HTTPContentFetcherInterface::getUserAgent() {
+inline std::string HTTPContentFetcherInterface::getUserAgent() {
     return "AvsDeviceSdk/" + utils::sdkVersion::getCurrentVersion();
 }
 
+inline std::string HTTPContentFetcherInterface::stateToString(HTTPContentFetcherInterface::State state) {
+    switch (state) {
+        case State::INITIALIZED:
+            return "INITIALIZED";
+        case State::FETCHING_HEADER:
+            return "FETCHING_HEADER";
+        case State::HEADER_DONE:
+            return "HEADER_DONE";
+        case State::FETCHING_BODY:
+            return "FETCHING_BODY";
+        case State::BODY_DONE:
+            return "BODY_DONE";
+        case State::ERROR:
+            return "ERROR";
+    }
+    return "";
+}
+
+/**
+ * Overwrites the << operator for @c HTTPContentFetcherInterface::State.
+ *
+ * @param os The output stream pointer.
+ * @param code The HTTPContentFetcherInterface::State to write to the output stream.
+ * @return The output stream pointer.
+ */
+inline std::ostream& operator<<(std::ostream& os, const HTTPContentFetcherInterface::State& state) {
+    os << HTTPContentFetcherInterface::stateToString(state);
+    return os;
+}
+
 }  // namespace sdkInterfaces
 }  // namespace avsCommon
 }  // namespace alexaClientSDK
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h
index e1d8fef..73fa1a4 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/MessageRequestObserverInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -129,7 +129,7 @@ inline std::ostream& operator<<(std::ostream& stream, MessageRequestObserverInte
         case MessageRequestObserverInterface::Status::INVALID_AUTH:
             return stream << "INVALID_AUTH";
         case MessageRequestObserverInterface::Status::BAD_REQUEST:
-            return stream << "BAD_REQUEST";
+            return stream << "CLIENT_ERROR_BAD_REQUEST";
         case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
             return stream << "SERVER_OTHER_ERROR";
     }
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
index 96c34b9..6bb55d3 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
@@ -31,6 +31,9 @@ public:
     MOCK_METHOD1(addDirectiveHandler, bool(std::shared_ptr<DirectiveHandlerInterface> handler));
     MOCK_METHOD1(removeDirectiveHandler, bool(std::shared_ptr<DirectiveHandlerInterface> handler));
     MOCK_METHOD1(setDialogRequestId, void(const std::string& dialogRequestId));
+    MOCK_METHOD0(getCurrentDialogRequestId, std::string());
+    MOCK_METHOD0(isCurrentDialogRequestOnline, bool());
+    MOCK_METHOD1(setIsCurrentDialogRequestOnline, void(bool));
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
     MOCK_METHOD0(doShutdown, void());
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/HTTP/HttpResponseCode.h b/AVSCommon/Utils/include/AVSCommon/Utils/HTTP/HttpResponseCode.h
new file mode 100644
index 0000000..be899b2
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/HTTP/HttpResponseCode.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_HTTP_HTTPRESPONSECODE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_HTTP_HTTPRESPONSECODE_H_
+
+#include <iostream>
+#include <string>
+
+#include "AVSCommon/Utils/Logger/LoggerUtils.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace http {
+
+enum HTTPResponseCode {
+    /// No HTTP response received.
+    HTTP_RESPONSE_CODE_UNDEFINED = 0,
+
+    /// HTTP Success with reponse payload.
+    SUCCESS_OK = 200,
+    /// HTTP Succcess with no response payload.
+    SUCCESS_NO_CONTENT = 204,
+
+    /// Multiple redirection choices
+    REDIRECTION_MULTIPLE_CHOICES = 300,
+    /// Content moved permanently
+    REDIRECTION_MOVED_PERMANENTLY = 301,
+    /// Content found on another URI
+    REDIRECTION_FOUND = 302,
+    /// See another - Should issue a GET to the other URI and assume that data was received on this request
+    REDIRECTION_SEE_ANOTHER = 303,
+    /// Content can be found on another URI, but the redirect should not be cached - cannot change HTTP method
+    REDIRECTION_TEMPORARY_REDIRECT = 307,
+    /// Content can be found on another URI, and the redirect should be cached - cannot change HTTP method
+    REDIRECTION_PERMANENT_REDIRECT = 308,
+
+    /// HTTP code for invalid request by user.
+    CLIENT_ERROR_BAD_REQUEST = 400,
+    /// HTTP code for forbidden request by user.
+    CLIENT_ERROR_FORBIDDEN = 403,
+
+    /// HTTP code for internal error by server which didn't fulfill the request.
+    SERVER_ERROR_INTERNAL = 500,
+
+    /// First success code
+    SUCCESS_START_CODE = SUCCESS_OK,
+    /// Last success code
+    SUCCESS_END_CODE = 299,
+
+    /// First code in redirection range.
+    REDIRECTION_START_CODE = REDIRECTION_MULTIPLE_CHOICES,
+    /// Last code in redirection range.
+    REDIRECTION_END_CODE = REDIRECTION_PERMANENT_REDIRECT
+};
+
+/**
+ * Checks if the status code is on the HTTP success range.
+ *
+ * @param code The status code to check
+ * @return @c true if it is on the success range
+ */
+inline bool isStatusCodeSuccess(HTTPResponseCode code) {
+    return (HTTPResponseCode::SUCCESS_START_CODE <= code) && (code <= HTTPResponseCode::SUCCESS_END_CODE);
+}
+
+/**
+ * Checks if the status code is on the HTTP redirect range.
+ *
+ * @param code The status code to check
+ * @return @c true if it is on the redirect range
+ */
+inline bool isRedirect(HTTPResponseCode code) {
+    // Not all 3xx codes are redirects and we should avoid proxy codes for security reasons. Therefore the safest way
+    // to check redirection is verifying code by code.
+    return HTTPResponseCode::REDIRECTION_MULTIPLE_CHOICES == code ||
+           HTTPResponseCode::REDIRECTION_MOVED_PERMANENTLY == code || HTTPResponseCode::REDIRECTION_FOUND == code ||
+           HTTPResponseCode::REDIRECTION_SEE_ANOTHER == code ||
+           HTTPResponseCode::REDIRECTION_TEMPORARY_REDIRECT == code ||
+           HTTPResponseCode::REDIRECTION_PERMANENT_REDIRECT == code;
+}
+
+/**
+ * Converts a response code in integer format to an @ HTTPResponseCode enumeration value. Gives an @c
+ * HTTP_RESPONSE_CODE_UNDEFINED if the response code is not mapped by any enumeration value.
+ *
+ * @param code The response code.
+ * @return The enumeration value.
+ */
+inline HTTPResponseCode intToHTTPResponseCode(int code) {
+    switch (code) {
+        case 200:
+            return HTTPResponseCode::SUCCESS_OK;
+        case 204:
+            return HTTPResponseCode::SUCCESS_NO_CONTENT;
+        case 300:
+            return HTTPResponseCode::REDIRECTION_MULTIPLE_CHOICES;
+        case 301:
+            return HTTPResponseCode::REDIRECTION_MOVED_PERMANENTLY;
+        case 302:
+            return HTTPResponseCode::REDIRECTION_FOUND;
+        case 303:
+            return HTTPResponseCode::REDIRECTION_SEE_ANOTHER;
+        case 307:
+            return HTTPResponseCode::REDIRECTION_TEMPORARY_REDIRECT;
+        case 308:
+            return HTTPResponseCode::REDIRECTION_PERMANENT_REDIRECT;
+        case 400:
+            return HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST;
+        case 403:
+            return HTTPResponseCode::CLIENT_ERROR_FORBIDDEN;
+        case 500:
+            return HTTPResponseCode::SERVER_ERROR_INTERNAL;
+    }
+    logger::acsdkError(
+        logger::LogEntry("HttpResponseCodes", __func__).d("code", code).m("Unknown HTTP response code."));
+    return HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED;
+}
+
+/**
+ * Converts a response code enum value to the code in int.
+ *
+ * @param responseCode The enum value.
+ * @return The equivalent int value.
+ */
+inline int responseCodeToInt(HTTPResponseCode responseCode) {
+    return static_cast<std::underlying_type<HTTPResponseCode>::type>(responseCode);
+}
+
+/**
+ * Produces the string representation of a response code value.
+ *
+ * @param responseCode The enumeration value.
+ * @return The string representation.
+ */
+inline std::string responseCodeToString(HTTPResponseCode responseCode) {
+    switch (responseCode) {
+        case HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED:
+            return "HTTP_RESPONSE_CODE_UNDEFINED";
+        case HTTPResponseCode::SUCCESS_OK:
+            return "SUCCESS_OK";
+        case HTTPResponseCode::SUCCESS_NO_CONTENT:
+            return "SUCCESS_NO_CONTENT";
+        case HTTPResponseCode::SUCCESS_END_CODE:
+            return "SUCCESS_END_CODE";
+        case HTTPResponseCode::REDIRECTION_MULTIPLE_CHOICES:
+            return "REDIRECTION_MULTIPLE_CHOICES";
+        case HTTPResponseCode::REDIRECTION_MOVED_PERMANENTLY:
+            return "REDIRECTION_MOVED_PERMANENTLY";
+        case HTTPResponseCode::REDIRECTION_FOUND:
+            return "REDIRECTION_FOUND";
+        case HTTPResponseCode::REDIRECTION_SEE_ANOTHER:
+            return "REDIRECTION_SEE_ANOTHER";
+        case HTTPResponseCode::REDIRECTION_TEMPORARY_REDIRECT:
+            return "REDIRECTION_TEMPORARY_REDIRECT";
+        case HTTPResponseCode::REDIRECTION_PERMANENT_REDIRECT:
+            return "REDIRECTION_PERMANENT_REDIRECT";
+        case HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST:
+            return "CLIENT_ERROR_BAD_REQUEST";
+        case HTTPResponseCode::CLIENT_ERROR_FORBIDDEN:
+            return "CLIENT_ERROR_FORBIDDEN";
+        case HTTPResponseCode::SERVER_ERROR_INTERNAL:
+            return "SERVER_ERROR_INTERNAL";
+    }
+    logger::acsdkError(logger::LogEntry("HttpResponseCodes", __func__)
+                           .d("longValue", static_cast<long>(responseCode))
+                           .m("Unknown HTTP response code."));
+    return "";
+}
+
+/**
+ * Overwrites the << operator for @c HTTPResponseCode.
+ *
+ * @param os The output stream pointer.
+ * @param code The HTTPResponseCode to write to the output stream.
+ * @return The output stream pointer.
+ */
+inline std::ostream& operator<<(std::ostream& os, const HTTPResponseCode& code) {
+    os << responseCodeToString(code);
+    return os;
+}
+
+}  // namespace http
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_HTTP_HTTPRESPONSECODE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h b/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h
index 17c3cf6..2c93919 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index 72a7834..19a190a 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -73,7 +73,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 0000000..0bfbaa1
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 0000000..1a948d8
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 0000000..5068502
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
new file mode 100644
index 0000000..770b206
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP GET requests.
+class HttpGetInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpGetInterface() = default;
+
+    /**
+     * Perform an HTTP Get request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the GET to.
+     * @param headers vector of strings to add in the header.
+     * @return An object describing the response to the GET request.
+     */
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h
index e5a358d..34253af 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -16,6 +16,14 @@
 #ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPRESPONSECODES_H_
 #define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPRESPONSECODES_H_
 
+/**
+ * An enum to represent HTTP response codes.
+ *
+ * ATTENTION - This enum has been deprecated and only exists to provide backward compatibility with code that was
+ * designed to work with past versions of the AVS C++ SDK.
+ *
+ * @deprecated Use the @c alexaClientSDK::avsCommon::utils::http::HTTPResponseCode instead.
+ */
 enum HTTPResponseCode {
     /// No HTTP response received.
     HTTP_RESPONSE_CODE_UNDEFINED = 0,
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibCurlHttpContentFetcher.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibCurlHttpContentFetcher.h
index 5e07bcf..09e4f33 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibCurlHttpContentFetcher.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/LibCurlHttpContentFetcher.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -37,13 +37,22 @@ class LibCurlHttpContentFetcher : public avsCommon::sdkInterfaces::HTTPContentFe
 public:
     LibCurlHttpContentFetcher(const std::string& url);
 
+    /// @name HTTPContentFetcherInterface methods
+    /// @{
+    State getState() override;
+    std::string getUrl() const override;
+    Header getHeader(std::atomic<bool>* shouldShutdown) override;
+    bool getBody(std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer) override;
+    void shutdown() override;
+    /// @}
+
     /**
      * @copydoc
      * In this implementation, the function may only be called once. Subsequent calls will return @c nullptr.
      */
     std::unique_ptr<avsCommon::utils::HTTPContent> getContent(
         FetchOptions option,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer = nullptr,
+        std::unique_ptr<avsCommon::avs::attachment::AttachmentWriter> writer = nullptr,
         const std::vector<std::string>& customHeaders = std::vector<std::string>()) override;
 
     /*
@@ -61,6 +70,9 @@ private:
     /// A no-op callback to not parse HTTP bodies.
     static size_t noopCallback(char* data, size_t size, size_t nmemb, void* userData);
 
+    /// The content fetching state
+    State m_state;
+
     /**
      * Helper method to get custom HTTP headers list.
      *
@@ -70,43 +82,31 @@ private:
     curl_slist* getCustomHeaderList(std::vector<std::string> customHeaders);
 
     /// The URL to fetch from.
-    std::string m_url;
+    const std::string m_url;
 
     /// A libcurl wrapper.
     CurlEasyHandleWrapper m_curlWrapper;
 
-    /// A promise to the caller of @c getContent() that the HTTP status code will be set.
-    std::promise<long> m_statusCodePromise;
+    /// A promise for header loading
+    std::promise<bool> m_headerPromise;
 
-    /// A promise to the caller of @c getContent() that the HTTP content type will be set.
-    std::promise<std::string> m_contentTypePromise;
+    /// A future for header loading
+    std::shared_future<bool> m_headerFuture;
+
+    /// The fetched header
+    HTTPContentFetcherInterface::Header m_header;
 
     /**
      * The writer used to write the HTTP body to, if desired by the caller of @c getContent().
      */
     std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> m_streamWriter;
 
-    /**
-     * The last status code parsed in an HTTP response header. Since we follow redirects, we only want the last status
-     * code.
-     */
-    long m_lastStatusCode;
-
-    /// The length of the content of the ongoing request.
-    ssize_t m_currentContentLength;
-
     /// Number of bytes that has been received in the ongoing request.
     ssize_t m_currentContentReceivedLength;
 
     /// Number of bytes that has been received since the first request.
     ssize_t m_totalContentReceivedLength;
 
-    /**
-     * The last content type parsed in an HTTP response header. Since we follow redirects, we only want the last content
-     * type.
-     */
-    std::string m_lastContentType;
-
     /// Flag to indicate that the data-fetch operation has completed.
     std::atomic<bool> m_done;
 
@@ -121,6 +121,39 @@ private:
 
     /// Flag to indicate that a call to @c getContent() has been made. Subsequent calls will not be accepted.
     std::atomic_flag m_hasObjectBeenUsed;
+
+    /// A mutex to ensure that all state transitions on the m_state variable are thead-safe.
+    std::mutex m_stateMutex;
+
+    /**
+     * A mutex to ensure that concurrent calls to getBody are thread-safe. The @c getBody() function should be called
+     * only once in order to ensure that the content fetcher receives a single attachment writer at the right state.
+     */
+    std::mutex m_getBodyMutex;
+
+    /**
+     * Writes an error in the logs warning us that an attempt to perform an invalid state transition was made.
+     *
+     * @param currentState The current state.
+     * @param newState The state to which the transition attempt was made.
+     */
+    void reportInvalidStateTransitionAttempt(State currentState, State newState);
+
+    /**
+     * Performs the state transition, guaranteeing it to be atomic in regard with the header and body future and the
+     * header successful field. If the transition is invalid, refrains from performing the transition and logs an error
+     * message.
+     *
+     * @param newState The new state.
+     * @param value The value of the the futures and the header successful field.
+     */
+    void stateTransition(State newState, bool value);
+
+    /**
+     * Checks if the content fetcher is still waiting for the @c getBody method to be called.
+     * @return @c true if it is still waiting for the method call.
+     */
+    bool waitingForBodyRequest();
 };
 
 }  // namespace libcurlUtils
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Network/InternetConnectionMonitor.h b/AVSCommon/Utils/include/AVSCommon/Utils/Network/InternetConnectionMonitor.h
index 84a74cd..d69ebf6 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Network/InternetConnectionMonitor.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Network/InternetConnectionMonitor.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -114,6 +114,9 @@ private:
     /// The timer that will call testConnection() every m_period seconds.
     avsCommon::utils::timing::Timer m_connectionTestTimer;
 
+    /// A flag to tell the HTTP content fetcher that it is time to shutdown.
+    std::atomic<bool> m_isShuttingDown;
+
     /// The stream that will hold downloaded data.
     std::shared_ptr<avsCommon::avs::attachment::InProcessAttachment> m_stream;
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/PlaylistParser/PlaylistEntry.h b/AVSCommon/Utils/include/AVSCommon/Utils/PlaylistParser/PlaylistEntry.h
index 364166b..3840e34 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/PlaylistParser/PlaylistEntry.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/PlaylistParser/PlaylistEntry.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -21,6 +21,9 @@
 #include <queue>
 #include <string>
 
+#include <AVSCommon/SDKInterfaces/HTTPContentFetcherInterface.h>
+#include <AVSCommon/Utils/HTTPContent.h>
+
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace utils {
@@ -73,9 +76,9 @@ struct EncryptionInfo {
     /**
      * Constructor.
      *
-     * @param _method The encryption method of media.
-     * @param _url The URL for the encryption key to download.
-     * @param _initVector The intilization vector used for encryption.
+     * @param method The encryption method of media.
+     * @param url The URL for the encryption key to download.
+     * @param initVector The intilization vector used for encryption.
      */
     EncryptionInfo(Method method, std::string url, std::string initVector = std::string());
 
@@ -108,7 +111,10 @@ struct PlaylistEntry {
         MEDIA_INFO,
 
         /// Playlist Entry is about media initialization.
-        MEDIA_INIT_INFO
+        MEDIA_INIT_INFO,
+
+        /// Playlist Entry is audio content, not a playlist.
+        AUDIO_CONTENT
     };
 
     /**
@@ -137,6 +143,7 @@ struct PlaylistEntry {
      * @param _type The Type of the entry.
      * @param _byteRange The byte range of the url to download. Default is (0, 0).
      * @param _encryptionInfo The encryption info of the media. Default value is NONE.
+     * @param _contentFetcher Content fetcher related to the entry.
      */
     PlaylistEntry(
         std::string _url,
@@ -144,7 +151,8 @@ struct PlaylistEntry {
         avsCommon::utils::playlistParser::PlaylistParseResult _parseResult,
         Type _type = Type::MEDIA_INFO,
         ByteRange _byteRange = std::make_tuple(0, 0),
-        EncryptionInfo _encryptionInfo = EncryptionInfo());
+        EncryptionInfo _encryptionInfo = EncryptionInfo(),
+        std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> _contentFetcher = nullptr);
 
     /**
      * Returns true if byterange is valid.
@@ -168,10 +176,15 @@ struct PlaylistEntry {
 
     /// EncryptionInfo of the media.
     EncryptionInfo encryptionInfo;
+
+    /// The content fetcher associated with this playlist item. If a content fetcher is set, then it should be
+    /// considered to be safe to use it. Otherwise, a new content fetcher should be created.
+    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher;
 };
 
 inline PlaylistEntry PlaylistEntry::createErrorEntry(const std::string& url) {
-    return PlaylistEntry(url, std::chrono::milliseconds(-1), PlaylistParseResult::ERROR);
+    return PlaylistEntry(
+        url, std::chrono::milliseconds(-1), PlaylistParseResult::ERROR, Type::MEDIA_INFO, std::make_tuple(0, 0));
 }
 
 inline PlaylistEntry PlaylistEntry::createMediaInitInfo(std::string url, ByteRange byteRange) {
@@ -204,13 +217,15 @@ inline PlaylistEntry::PlaylistEntry(
     avsCommon::utils::playlistParser::PlaylistParseResult _parseResult,
     Type _type,
     ByteRange _byteRange,
-    EncryptionInfo _encryptionInfo) :
+    EncryptionInfo _encryptionInfo,
+    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> _contentFetcher) :
         type(_type),
         url(_url),
         duration(_duration),
         parseResult(_parseResult),
         byteRange(_byteRange),
-        encryptionInfo(_encryptionInfo) {
+        encryptionInfo(_encryptionInfo),
+        contentFetcher(_contentFetcher) {
 }
 
 }  // namespace playlistParser
diff --git a/AVSCommon/Utils/src/HTTP2/HTTP2MimeResponseDecoder.cpp b/AVSCommon/Utils/src/HTTP2/HTTP2MimeResponseDecoder.cpp
index 5741d0e..55b0386 100644
--- a/AVSCommon/Utils/src/HTTP2/HTTP2MimeResponseDecoder.cpp
+++ b/AVSCommon/Utils/src/HTTP2/HTTP2MimeResponseDecoder.cpp
@@ -15,14 +15,16 @@
 
 #include <AVSCommon/Utils/Logger/Logger.h>
 
+#include "AVSCommon/Utils/HTTP/HttpResponseCode.h"
 #include "AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h"
-#include "AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h"
 
 namespace alexaClientSDK {
 namespace avsCommon {
 namespace utils {
 namespace http2 {
 
+using namespace avsCommon::utils::http;
+
 /// String to identify log entries originating from this file.
 static const std::string TAG("HTTP2MimeResponseDecoder");
 
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index 711d4e2..c98470e 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -15,9 +15,9 @@
 
 #include <iostream>
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include "AVSCommon/Utils/Configuration/ConfigurationNode.h"
 #include <AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
@@ -32,7 +32,7 @@ namespace avsCommon {
 namespace utils {
 namespace libcurlUtils {
 
-using namespace alexaClientSDK::avsCommon::utils;
+using namespace avsCommon::utils::http;
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("CurlEasyHandleWrapper");
@@ -242,6 +242,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlMultiHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlMultiHandleWrapper.cpp
index bdf158d..9d25c27 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlMultiHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlMultiHandleWrapper.cpp
@@ -21,8 +21,6 @@ namespace avsCommon {
 namespace utils {
 namespace libcurlUtils {
 
-using namespace alexaClientSDK::avsCommon::utils;
-
 /// String to identify log entries originating from this file.
 static const std::string TAG("CurlMultiHandleWrapper");
 
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp b/AVSCommon/Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
index 4610459..78a2096 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
 
 #include <AVSCommon/Utils/LibcurlUtils/HTTPContentFetcherFactory.h>
 #include <AVSCommon/Utils/LibcurlUtils/LibCurlHttpContentFetcher.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/Memory/Memory.h>
 
 namespace alexaClientSDK {
@@ -22,8 +23,19 @@ namespace avsCommon {
 namespace utils {
 namespace libcurlUtils {
 
+/// String to identify log entries originating from this file.
+static const std::string TAG("HTTPContentFetcherFactory");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
 std::unique_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> HTTPContentFetcherFactory::create(
     const std::string& url) {
+    ACSDK_DEBUG9(LX(__func__).sensitive("URL", url).m("Creating a new http content fetcher"));
     return avsCommon::utils::memory::make_unique<LibCurlHttpContentFetcher>(url);
 }
 
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 0000000..b41bace
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 0000000..ee45dfd
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpPost.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpPost.cpp
index 15ded3d..4574737 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/HttpPost.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpPost.cpp
@@ -15,8 +15,8 @@
 
 #include <sstream>
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/LibcurlUtils/HttpPost.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpPut.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpPut.cpp
index 221f3cd..295e4be 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/HttpPut.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpPut.cpp
@@ -19,8 +19,8 @@
 #include <cstring>
 #include <vector>
 
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
 namespace alexaClientSDK {
diff --git a/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp b/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
index 315570a..d80ba49 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -14,10 +14,12 @@
  */
 
 #include <algorithm>
+#include <chrono>
 
+#include <AVSCommon/SDKInterfaces/HTTPContentFetcherInterface.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h>
 #include "AVSCommon/Utils/LibcurlUtils/CurlMultiHandleWrapper.h"
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/LibcurlUtils/LibCurlHttpContentFetcher.h>
 #include <AVSCommon/Utils/Memory/Memory.h>
 #include <AVSCommon/Utils/SDS/InProcessSDS.h>
@@ -27,6 +29,10 @@ namespace avsCommon {
 namespace utils {
 namespace libcurlUtils {
 
+using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::utils::http;
+using namespace avsCommon::utils::libcurlUtils;
+
 /// String to identify log entries originating from this file.
 static const std::string TAG("LibCurlHttpContentFetcher");
 
@@ -35,10 +41,14 @@ static const std::string TAG("LibCurlHttpContentFetcher");
  * may also increase latency.
  */
 static const std::chrono::milliseconds TIMEOUT_FOR_BLOCKING_WRITE = std::chrono::milliseconds(100);
-/// Timeout for curl_multi_wait.
-static const auto WAIT_FOR_ACTIVITY_TIMEOUT = std::chrono::milliseconds(100);
+/// Timeout for polling loops that check activities running on separate threads.
+static const std::chrono::milliseconds WAIT_FOR_ACTIVITY_TIMEOUT{100};
 /// Timeout for curl connection.
 static const auto TIMEOUT_CONNECTION = std::chrono::seconds(30);
+/// Timeout to wait for a call to get body after getContent was called
+static const std::chrono::minutes MAX_GET_BODY_WAIT{1};
+/// Timeout to wait for get header to complete
+static const std::chrono::minutes MAX_GET_HEADER_WAIT{5};
 
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
@@ -52,16 +62,21 @@ size_t LibCurlHttpContentFetcher::headerCallback(char* data, size_t size, size_t
         ACSDK_ERROR(LX("headerCallback").d("reason", "nullUserDataPointer"));
         return 0;
     }
+    auto fetcher = static_cast<LibCurlHttpContentFetcher*>(userData);
+
+    ACSDK_DEBUG9(LX(__func__).sensitive("url", fetcher->m_url).m("CALLED"));
+
+    fetcher->stateTransition(State::FETCHING_HEADER, true);
+
     std::string line(static_cast<const char*>(data), size * nmemb);
     std::transform(line.begin(), line.end(), line.begin(), ::tolower);
     if (line.find("http") == 0) {
         // To find lines like: "HTTP/1.1 200 OK"
         std::istringstream iss(line);
         std::string httpVersion;
-        long statusCode;
+        int statusCode = 0;
         iss >> httpVersion >> statusCode;
-        LibCurlHttpContentFetcher* thisObject = static_cast<LibCurlHttpContentFetcher*>(userData);
-        thisObject->m_lastStatusCode = statusCode;
+        fetcher->m_header.responseCode = intToHTTPResponseCode(statusCode);
     } else if (line.find("content-type") == 0) {
         // To find lines like: "Content-Type: audio/x-mpegurl; charset=utf-8"
         std::istringstream iss(line);
@@ -74,22 +89,20 @@ size_t LibCurlHttpContentFetcher::headerCallback(char* data, size_t size, size_t
             // Remove characters after the separator ;
             contentType.erase(separator);
         }
-        LibCurlHttpContentFetcher* thisObject = static_cast<LibCurlHttpContentFetcher*>(userData);
-        thisObject->m_lastContentType = contentType;
+        fetcher->m_header.contentType = contentType;
     } else if (line.find("content-length") == 0) {
         // To find lines like: "Content-Length: 12345"
         std::istringstream iss(line);
-        std::string contentTypeBeginning;
-        LibCurlHttpContentFetcher* thisObject = static_cast<LibCurlHttpContentFetcher*>(userData);
-        iss >> contentTypeBeginning >> thisObject->m_currentContentLength;
-        ACSDK_DEBUG9(LX(__func__).d("type", "content-length").d("length", thisObject->m_currentContentLength));
+        std::string contentLengthBeginning;
+        iss >> contentLengthBeginning >> fetcher->m_header.contentLength;
+        ACSDK_DEBUG9(LX(__func__).d("type", "content-length").d("length", fetcher->m_header.contentLength));
     } else if (line.find("content-range") == 0) {
         // To find lines like: "Content-Range: bytes 1000-3979/3980"
         std::istringstream iss(line);
-        std::string contentTypeBeginning;
+        std::string contentRangeBeginning;
         std::string contentUnit;
         std::string range;
-        iss >> contentTypeBeginning >> contentUnit >> range;
+        iss >> contentRangeBeginning >> contentUnit >> range;
         ACSDK_DEBUG9(LX(__func__).d("type", "content-range").d("unit", contentUnit).d("range", range));
     }
     return size * nmemb;
@@ -100,20 +113,50 @@ size_t LibCurlHttpContentFetcher::bodyCallback(char* data, size_t size, size_t n
         ACSDK_ERROR(LX("bodyCallback").d("reason", "nullUserDataPointer"));
         return 0;
     }
-    LibCurlHttpContentFetcher* thisObject = static_cast<LibCurlHttpContentFetcher*>(userData);
-    if (thisObject->m_done) {
+    auto fetcher = static_cast<LibCurlHttpContentFetcher*>(userData);
+    if (fetcher->m_done) {
         // In order to properly quit when downloading live content, which block forever when performing a GET request
         return 0;
     }
-    auto streamWriter = thisObject->m_streamWriter;
+
+    if (State::FETCHING_HEADER == fetcher->getState()) {
+        ACSDK_DEBUG9(LX(__func__).sensitive("url", fetcher->m_url).m("End of header found."));
+        fetcher->stateTransition(State::HEADER_DONE, true);
+    }
+
+    // Waits until the content fetcher is shutting down or the @c getBody method gets called.
+    auto startTime = std::chrono::steady_clock::now();
+    auto elapsedTime = std::chrono::steady_clock::now() - startTime;
+    while ((MAX_GET_BODY_WAIT > elapsedTime) && !fetcher->m_isShutdown && fetcher->waitingForBodyRequest()) {
+        std::this_thread::sleep_for(WAIT_FOR_ACTIVITY_TIMEOUT);
+        elapsedTime = std::chrono::steady_clock::now() - startTime;
+    }
+    if (MAX_GET_BODY_WAIT <= elapsedTime) {
+        ACSDK_ERROR(LX(__func__).d("reason", "getBodyCallWaitTimeout"));
+        fetcher->stateTransition(State::ERROR, false);
+        return 0;
+    }
+    if (fetcher->m_isShutdown) {
+        return 0;
+    }
+
+    fetcher->stateTransition(State::FETCHING_BODY, true);
+
+    if (!fetcher->m_streamWriter) {
+        ACSDK_DEBUG9(LX(__func__).m("No writer received. Creating a new one."));
+        // Using the url as the identifier for the attachment
+        auto stream = std::make_shared<avsCommon::avs::attachment::InProcessAttachment>(fetcher->m_url);
+        fetcher->m_streamWriter = stream->createWriter(sds::WriterPolicy::BLOCKING);
+    }
+
+    auto streamWriter = fetcher->m_streamWriter;
     size_t totalBytesWritten = 0;
 
     if (streamWriter) {
         size_t targetNumBytes = size * nmemb;
 
-        while (totalBytesWritten < targetNumBytes && !thisObject->m_done) {
-            avsCommon::avs::attachment::AttachmentWriter::WriteStatus writeStatus =
-                avsCommon::avs::attachment::AttachmentWriter::WriteStatus::OK;
+        while ((totalBytesWritten < targetNumBytes) && !fetcher->m_done) {
+            auto writeStatus = avsCommon::avs::attachment::AttachmentWriter::WriteStatus::OK;
 
             size_t numBytesWritten = streamWriter->write(
                 data,
@@ -136,19 +179,20 @@ size_t LibCurlHttpContentFetcher::bodyCallback(char* data, size_t size, size_t n
                     ACSDK_ERROR(LX(__func__).d("unexpected return code", "OK_BUFFER_FULL"));
                     return 0;
             }
-            ACSDK_ERROR(LX(__func__).m("unexpected writeStatus"));
+            ACSDK_ERROR(LX("UnexpectedWriteStatus").d("writeStatus", static_cast<int>(writeStatus)));
             return 0;
         }
     }
 
-    thisObject->m_totalContentReceivedLength += totalBytesWritten;
-    thisObject->m_currentContentReceivedLength += totalBytesWritten;
+    fetcher->m_totalContentReceivedLength += totalBytesWritten;
+    fetcher->m_currentContentReceivedLength += totalBytesWritten;
 
     ACSDK_DEBUG9(LX(__func__)
-                     .d("totalContentReceived", thisObject->m_totalContentReceivedLength)
-                     .d("currentContentLength", thisObject->m_currentContentLength)
-                     .d("currentContentReceived", thisObject->m_currentContentReceivedLength)
-                     .d("remaining", thisObject->m_currentContentLength - thisObject->m_currentContentReceivedLength));
+                     .d("totalContentReceived", fetcher->m_totalContentReceivedLength)
+                     .d("contentLength", fetcher->m_header.contentLength)
+                     .d("currentContentReceived", fetcher->m_currentContentReceivedLength)
+                     .d("remaining", fetcher->m_header.contentLength - fetcher->m_currentContentReceivedLength)
+                     .d("totalBytesWritten", totalBytesWritten));
 
     return totalBytesWritten;
 }
@@ -158,31 +202,87 @@ size_t LibCurlHttpContentFetcher::noopCallback(char* data, size_t size, size_t n
 }
 
 LibCurlHttpContentFetcher::LibCurlHttpContentFetcher(const std::string& url) :
+        m_state{HTTPContentFetcherInterface::State::INITIALIZED},
         m_url{url},
-        m_lastStatusCode{0},
-        m_currentContentLength{0},
         m_currentContentReceivedLength{0},
         m_totalContentReceivedLength{0},
         m_done{false},
         m_isShutdown{false} {
     m_hasObjectBeenUsed.clear();
+    m_headerFuture = m_headerPromise.get_future();
+}
+
+HTTPContentFetcherInterface::State LibCurlHttpContentFetcher::getState() {
+    std::lock_guard<std::mutex> lock(m_stateMutex);
+    return m_state;
+}
+
+std::string LibCurlHttpContentFetcher::getUrl() const {
+    return m_url;
+}
+
+HTTPContentFetcherInterface::Header LibCurlHttpContentFetcher::getHeader(std::atomic<bool>* shouldShutdown) {
+    // Creates a copy of the future for the current thread
+    auto localFuture = m_headerFuture;
+    auto startTime = std::chrono::steady_clock::now();
+    auto elapsedTime = std::chrono::steady_clock::now() - startTime;
+    while ((MAX_GET_HEADER_WAIT > elapsedTime) && !m_isShutdown && (!shouldShutdown || !(*shouldShutdown))) {
+        if (State::ERROR == getState()) {
+            ACSDK_ERROR(LX(__func__).sensitive("URL", m_url).d("reason", "Invalid state").d("state", "ERROR"));
+            m_header.successful = false;
+            return m_header;
+        }
+        std::future_status status = localFuture.wait_for(std::chrono::milliseconds(WAIT_FOR_ACTIVITY_TIMEOUT));
+        if (std::future_status::ready == status) {
+            break;
+        }
+        elapsedTime = std::chrono::steady_clock::now() - startTime;
+    }
+    if (MAX_GET_HEADER_WAIT <= elapsedTime) {
+        ACSDK_ERROR(LX("getHeaderFailed").d("reason", "waitTimeout"));
+        m_header.successful = false;
+    }
+    return m_header;
+}
+
+bool LibCurlHttpContentFetcher::getBody(std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer) {
+    std::lock_guard<std::mutex> lock(m_getBodyMutex);
+    if (State::ERROR == getState()) {
+        return false;
+    }
+    if (!waitingForBodyRequest()) {
+        ACSDK_ERROR(LX(__func__).d("reason", "functionAlreadyCalled"));
+        return false;
+    }
+    m_streamWriter = writer;
+    stateTransition(State::FETCHING_BODY, true);
+    return true;
+}
+
+void LibCurlHttpContentFetcher::shutdown() {
+    ACSDK_DEBUG9(LX(__func__).m("Shutting down"));
+    m_isShutdown = true;
+    stateTransition(State::BODY_DONE, true);
 }
 
 std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getContent(
     FetchOptions fetchOption,
-    std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer,
+    std::unique_ptr<avsCommon::avs::attachment::AttachmentWriter> attachmentWriter,
     const std::vector<std::string>& customHeaders) {
     if (m_hasObjectBeenUsed.test_and_set()) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "Object has already been used"));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
     if (!m_curlWrapper.setURL(m_url)) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "failedToSetUrl"));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
     auto curlReturnValue = curl_easy_setopt(m_curlWrapper.getCurlHandle(), CURLOPT_FOLLOWLOCATION, 1L);
     if (curlReturnValue != CURLE_OK) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "enableFollowRedirectsFailed").d("error", curlReturnValue));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
     curlReturnValue = curl_easy_setopt(m_curlWrapper.getCurlHandle(), CURLOPT_AUTOREFERER, 1L);
@@ -190,22 +290,26 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
         ACSDK_ERROR(LX("getContentFailed")
                         .d("reason", "enableAutoReferralSettingToRedirectsFailed")
                         .d("error", curlReturnValue));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
     // This enables the libcurl cookie engine, allowing it to send cookies
     curlReturnValue = curl_easy_setopt(m_curlWrapper.getCurlHandle(), CURLOPT_COOKIEFILE, "");
     if (curlReturnValue != CURLE_OK) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "enableLibCurlCookieEngineFailed").d("error", curlReturnValue));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
     if (!m_curlWrapper.setConnectionTimeout(TIMEOUT_CONNECTION)) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "setConnectionTimeoutFailed"));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
 
     curl_slist* headerList = getCustomHeaderList(customHeaders);
     if (headerList && curl_easy_setopt(m_curlWrapper.getCurlHandle(), CURLOPT_HTTPHEADER, headerList) != CURLE_OK) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "setCustomHeadersFailed"));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
 
@@ -214,13 +318,11 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
         CURLOPT_USERAGENT,
         sdkInterfaces::HTTPContentFetcherInterface::getUserAgent().c_str());
     if (curlReturnValue != CURLE_OK) {
-        ACSDK_ERROR(LX("getContentFailed").d("reason", "setUserAgentFailed").d("error", curlReturnValue));
+        ACSDK_ERROR(LX("getContentFailed").d("reason", "setCurlOptRangeFailed").d("error", curlReturnValue));
+        stateTransition(State::ERROR, false);
         return nullptr;
     }
 
-    auto httpStatusCodeFuture = m_statusCodePromise.get_future();
-    auto contentTypeFuture = m_contentTypePromise.get_future();
-
     std::shared_ptr<avsCommon::avs::attachment::InProcessAttachment> stream = nullptr;
 
     // This flag will remain false if the caller of getContent() passed in their own writer.
@@ -238,20 +340,20 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
                 ACSDK_ERROR(LX("getContentFailed").d("reason", "failedToSetCurlCallback"));
                 return nullptr;
             }
-
+            stateTransition(State::FETCHING_HEADER, true);
             m_thread = std::thread([this, headerList]() {
-                auto curlMultiHandle = avsCommon::utils::libcurlUtils::CurlMultiHandleWrapper::create();
+                auto curlMultiHandle = CurlMultiHandleWrapper::create();
                 if (!curlMultiHandle) {
                     ACSDK_ERROR(LX("getContentFailed").d("reason", "curlMultiHandleWrapperCreateFailed"));
                     // Set the promises because of errors.
-                    m_statusCodePromise.set_value(0);
-                    m_contentTypePromise.set_value("");
+                    m_header.responseCode = HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED;
+                    m_header.contentType = "";
                     return;
                 }
                 curlMultiHandle->addHandle(m_curlWrapper.getCurlHandle());
 
                 int numTransfersLeft = 1;
-                long finalResponseCode = 0;
+                HTTPResponseCode finalResponseCode = HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED;
                 char* contentType = nullptr;
 
                 while (numTransfersLeft && !m_isShutdown) {
@@ -263,18 +365,20 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
                         break;
                     }
 
+                    int finalResponseCodeId = 0;
                     auto curlReturnValue =
-                        curl_easy_getinfo(m_curlWrapper.getCurlHandle(), CURLINFO_RESPONSE_CODE, &finalResponseCode);
+                        curl_easy_getinfo(m_curlWrapper.getCurlHandle(), CURLINFO_RESPONSE_CODE, &finalResponseCodeId);
+                    finalResponseCode = intToHTTPResponseCode(finalResponseCode);
                     if (curlReturnValue != CURLE_OK) {
                         ACSDK_ERROR(LX("curlEasyGetInfoFailed").d("error", curl_easy_strerror(curlReturnValue)));
                         break;
                     }
-                    if (0 != finalResponseCode && (finalResponseCode < HTTPResponseCode::REDIRECTION_START_CODE ||
-                                                   finalResponseCode > HTTPResponseCode::REDIRECTION_END_CODE)) {
+                    if (HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED != finalResponseCode &&
+                        !isRedirect(finalResponseCode)) {
                         ACSDK_DEBUG9(LX("getContent").d("responseCode", finalResponseCode).sensitive("url", m_url));
                         curlReturnValue =
                             curl_easy_getinfo(m_curlWrapper.getCurlHandle(), CURLINFO_CONTENT_TYPE, &contentType);
-                        if (curlReturnValue == CURLE_OK && contentType) {
+                        if ((curlReturnValue == CURLE_OK) && contentType) {
                             ACSDK_DEBUG9(LX("getContent").d("contentType", contentType).sensitive("url", m_url));
                         } else {
                             ACSDK_ERROR(LX("curlEasyGetInfoFailed").d("error", curl_easy_strerror(curlReturnValue)));
@@ -293,12 +397,6 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
                         break;
                     }
                 }
-                m_statusCodePromise.set_value(finalResponseCode);
-                if (contentType) {
-                    m_contentTypePromise.set_value(std::string(contentType));
-                } else {
-                    m_contentTypePromise.set_value("");
-                }
 
                 // Free custom headers.
                 curl_slist_free_all(headerList);
@@ -308,46 +406,42 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
             });
             break;
         case FetchOptions::ENTIRE_BODY:
-            if (!writer) {
-                // Using the url as the identifier for the attachment
-                stream = std::make_shared<avsCommon::avs::attachment::InProcessAttachment>(m_url);
-                writer = stream->createWriter(sds::WriterPolicy::BLOCKING);
-                writerWasCreatedLocally = true;
-            }
 
-            m_streamWriter = writer;
-
-            if (!m_streamWriter) {
-                ACSDK_ERROR(LX("getContentFailed").d("reason", "failedToCreateWriter"));
-                return nullptr;
-            }
+            stateTransition(State::FETCHING_HEADER, true);
             if (!m_curlWrapper.setWriteCallback(bodyCallback, this)) {
                 ACSDK_ERROR(LX("getContentFailed").d("reason", "failedToSetCurlBodyCallback"));
+                stateTransition(State::ERROR, false);
                 return nullptr;
             }
             if (!m_curlWrapper.setHeaderCallback(headerCallback, this)) {
                 ACSDK_ERROR(LX("getContentFailed").d("reason", "failedToSetCurlHeaderCallback"));
+                stateTransition(State::ERROR, false);
                 return nullptr;
             }
+
             m_thread = std::thread([this, writerWasCreatedLocally, headerList]() {
+                ACSDK_DEBUG9(LX("transferThread").sensitive("URL", m_url).m("start"));
                 auto curlMultiHandle = avsCommon::utils::libcurlUtils::CurlMultiHandleWrapper::create();
                 if (!curlMultiHandle) {
                     ACSDK_ERROR(LX("getContentFailed").d("reason", "curlMultiHandleWrapperCreateFailed"));
                     // Set the promises because of errors.
-                    m_statusCodePromise.set_value(0);
-                    m_contentTypePromise.set_value("");
+                    m_header.responseCode = HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED;
+                    m_header.contentType = "";
+                    stateTransition(State::ERROR, false);
                     return;
                 }
                 curlMultiHandle->addHandle(m_curlWrapper.getCurlHandle());
 
                 int numTransfersLeft = 1;
                 while (numTransfersLeft && !m_isShutdown) {
+                    ACSDK_DEBUG9(LX("transferThread").sensitive("URL", m_url).d("numTransfersLeft", numTransfersLeft));
                     auto result = curlMultiHandle->perform(&numTransfersLeft);
                     if (CURLM_CALL_MULTI_PERFORM == result) {
                         continue;
                     } else if (CURLM_OK != result) {
-                        ACSDK_ERROR(LX("getContentFailed").d("reason", "performFailed"));
-                        break;
+                        ACSDK_ERROR(LX("getContentFailed").sensitive("URL", m_url).d("reason", "performFailed"));
+                        stateTransition(State::ERROR, false);
+                        return;
                     }
 
                     int numTransfersUpdated = 0;
@@ -356,21 +450,22 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
                         ACSDK_ERROR(LX("getContentFailed")
                                         .d("reason", "multiWaitFailed")
                                         .d("error", curl_multi_strerror(result)));
-                        break;
+                        stateTransition(State::ERROR, false);
+                        return;
                     }
 
-                    auto bytesRemaining = m_currentContentLength - m_currentContentReceivedLength;
+                    auto bytesRemaining = m_header.contentLength - m_currentContentReceivedLength;
                     if (bytesRemaining < 0) {
                         bytesRemaining = 0;
                     }
 
                     // There's still byte remaining to download, let's try to get the rest of the data by using range.
-                    if (numTransfersLeft == 0 && bytesRemaining > 0) {
+                    if ((numTransfersLeft == 0) && bytesRemaining > 0) {
                         // Remove the current curlHandle from the multiHandle first.
                         curlMultiHandle->removeHandle(m_curlWrapper.getCurlHandle());
 
                         // Reset the current content counters.
-                        m_currentContentLength = 0;
+                        m_header.contentLength = 0;
                         m_currentContentReceivedLength = 0;
 
                         // Set the range to start with total content that's been received so far to the end.
@@ -381,6 +476,7 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
                         if (curlReturnValue != CURLE_OK) {
                             ACSDK_ERROR(
                                 LX("getContentFailed").d("reason", "setUserAgentFailed").d("error", curlReturnValue));
+                            stateTransition(State::ERROR, false);
                             return;
                         }
 
@@ -397,13 +493,11 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
                     }
                 }
 
-                m_statusCodePromise.set_value(m_lastStatusCode);
-                m_contentTypePromise.set_value(m_lastContentType);
-
                 /*
                  * If the writer was created locally, its job is done and can be safely closed.
                  */
                 if (writerWasCreatedLocally) {
+                    ACSDK_DEBUG9(LX(__func__).m("Closing the writer"));
                     m_streamWriter->close();
                 }
 
@@ -419,13 +513,21 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
 
                 // Abort any curl operation by removing the curl handle.
                 curlMultiHandle->removeHandle(m_curlWrapper.getCurlHandle());
+
+                if (State::INITIALIZED == getState() || State::ERROR == getState()) {
+                    ACSDK_DEBUG9(LX("transferThread").sensitive("URL", m_url).m("end with error"));
+                    stateTransition(State::ERROR, false);
+                } else {
+                    ACSDK_DEBUG9(LX("transferThread").sensitive("URL", m_url).m("end"));
+                    stateTransition(State::BODY_DONE, true);
+                }
             });
             break;
         default:
+            stateTransition(State::ERROR, false);
             return nullptr;
     }
-    return avsCommon::utils::memory::make_unique<avsCommon::utils::HTTPContent>(
-        std::move(httpStatusCodeFuture), std::move(contentTypeFuture), stream);
+    return nullptr;
 }
 
 curl_slist* LibCurlHttpContentFetcher::getCustomHeaderList(std::vector<std::string> customHeaders) {
@@ -438,14 +540,148 @@ curl_slist* LibCurlHttpContentFetcher::getCustomHeaderList(std::vector<std::stri
 }
 
 LibCurlHttpContentFetcher::~LibCurlHttpContentFetcher() {
-    ACSDK_DEBUG9(LX("~LibCurlHttpContentFetcher"));
+    ACSDK_DEBUG9(LX("~LibCurlHttpContentFetcher").sensitive("URL", m_url));
     if (m_thread.joinable()) {
         m_done = true;
         m_isShutdown = true;
+        stateTransition(State::BODY_DONE, true);
         m_thread.join();
     }
 }
 
+void LibCurlHttpContentFetcher::reportInvalidStateTransitionAttempt(State currentState, State newState) {
+    ACSDK_ERROR(LX(__func__)
+                    .d("currentState", currentState)
+                    .d("newState", newState)
+                    .m("An attempt was made to perform an invalid state transition."));
+}
+
+void LibCurlHttpContentFetcher::stateTransition(State newState, bool value) {
+    std::lock_guard<std::mutex> lock(m_stateMutex);
+    switch (m_state) {
+        case State::INITIALIZED:
+            switch (newState) {
+                case State::INITIALIZED:
+                    return;
+                case State::FETCHING_HEADER:
+                    break;
+                case State::HEADER_DONE:
+                    m_header.successful = value;
+                    m_headerPromise.set_value(value);
+                    break;
+                case State::FETCHING_BODY:
+                    m_header.successful = value;
+                    m_headerPromise.set_value(value);
+                    break;
+                case State::BODY_DONE:
+                    m_header.successful = value;
+                    m_headerPromise.set_value(value);
+                    break;
+                case State::ERROR:
+                    m_header.successful = false;
+                    m_headerPromise.set_value(false);
+                    break;
+            }
+            break;
+        case State::FETCHING_HEADER:
+            switch (newState) {
+                case State::INITIALIZED:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::FETCHING_HEADER:
+                    return;
+                case State::HEADER_DONE:
+                    m_header.successful = value;
+                    m_headerPromise.set_value(value);
+                    break;
+                case State::FETCHING_BODY:
+                    m_header.successful = value;
+                    m_headerPromise.set_value(value);
+                    break;
+                case State::BODY_DONE:
+                    m_header.successful = value;
+                    m_headerPromise.set_value(value);
+                    break;
+                case State::ERROR:
+                    m_header.successful = false;
+                    m_headerPromise.set_value(false);
+                    break;
+            }
+            break;
+        case State::HEADER_DONE:
+            switch (newState) {
+                case State::INITIALIZED:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::FETCHING_HEADER:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::HEADER_DONE:
+                    return;
+                case State::FETCHING_BODY:
+                    break;
+                case State::BODY_DONE:
+                    break;
+                case State::ERROR:
+                    break;
+            }
+            break;
+        case State::FETCHING_BODY:
+            switch (newState) {
+                case State::INITIALIZED:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::FETCHING_HEADER:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::HEADER_DONE:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::FETCHING_BODY:
+                    return;
+                case State::BODY_DONE:
+                    break;
+                case State::ERROR:
+                    break;
+            }
+            break;
+        case State::BODY_DONE:
+            switch (newState) {
+                case State::INITIALIZED:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::FETCHING_HEADER:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::HEADER_DONE:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::FETCHING_BODY:
+                    reportInvalidStateTransitionAttempt(m_state, newState);
+                    return;
+                case State::BODY_DONE:
+                    return;
+                case State::ERROR:
+                    break;
+            }
+            break;
+        case State::ERROR:
+            return;
+    }
+    if (State::ERROR == newState) {
+        ACSDK_ERROR(LX(__func__).sensitive("URL", m_url).d("oldState", m_state).m("State transition to ERROR"));
+    } else {
+        ACSDK_DEBUG9(
+            LX(__func__).sensitive("URL", m_url).d("oldState", m_state).d("newState", newState).m("State transition"));
+    }
+    m_state = newState;
+}
+
+bool LibCurlHttpContentFetcher::waitingForBodyRequest() {
+    State state = getState();
+    return (State::INITIALIZED == state) || (State::FETCHING_HEADER == state) || (State::HEADER_DONE == state);
+}
+
 }  // namespace libcurlUtils
 }  // namespace utils
 }  // namespace avsCommon
diff --git a/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp b/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
index 538a689..48e91af 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
@@ -27,6 +27,7 @@ namespace utils {
 namespace libcurlUtils {
 
 using namespace avsCommon::utils::http2;
+using namespace avsCommon::utils::libcurlUtils;
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("LibcurlHTTP2Connection");
diff --git a/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Request.cpp b/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Request.cpp
index f8c0a44..81a8aa2 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Request.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/LibcurlHTTP2Request.cpp
@@ -13,7 +13,7 @@
  * permissions and limitations under the License.
  */
 
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include "AVSCommon/Utils/LibcurlUtils/LibcurlHTTP2Request.h"
 #include <AVSCommon/Utils/Logger/Logger.h>
 
diff --git a/AVSCommon/Utils/src/Network/InternetConnectionMonitor.cpp b/AVSCommon/Utils/src/Network/InternetConnectionMonitor.cpp
index 41a41a4..2cb204b 100644
--- a/AVSCommon/Utils/src/Network/InternetConnectionMonitor.cpp
+++ b/AVSCommon/Utils/src/Network/InternetConnectionMonitor.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -20,7 +20,9 @@ namespace avsCommon {
 namespace utils {
 namespace network {
 
+using namespace avsCommon::avs::attachment;
 using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::utils::sds;
 using namespace utils::timing;
 
 /// String to identify log entries originating from this file.
@@ -39,12 +41,18 @@ static const size_t CHUNK_SIZE(1024);
 /// The amount of time to wait before retesting for internet connection availability.
 static const std::chrono::minutes DEFAULT_TEST_PERIOD{5};
 
+/// Timeout for polling loops that check shutdown.
+static const std::chrono::milliseconds WAIT_FOR_ACTIVITY_TIMEOUT{100};
+
 /// The URL to fetch content from.
 static const std::string S3_TEST_URL = "http://spectrum.s3.amazonaws.com/kindle-wifi/wifistub.html";
 
 /// The string that will serve as validation that the HTTP content was received correctly.
 static const std::string VALIDATION_STRING = "81ce4465-7167-4dcb-835b-dcc9e44c112a";
 
+/// Process attachment ID prefix
+static const std::string PROCESS_ATTACHMENT_ID_PREFIX = "download:";
+
 std::unique_ptr<InternetConnectionMonitor> InternetConnectionMonitor::create(
     std::shared_ptr<sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory) {
     if (!contentFetcherFactory) {
@@ -59,6 +67,7 @@ InternetConnectionMonitor::InternetConnectionMonitor(
     std::shared_ptr<sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory) :
         m_connected{false},
         m_period{DEFAULT_TEST_PERIOD},
+        m_isShuttingDown{false},
         m_contentFetcherFactory{contentFetcherFactory} {
     /// Using the test URL as the stream id.
     m_stream = std::make_shared<avs::attachment::InProcessAttachment>(S3_TEST_URL);
@@ -113,6 +122,7 @@ void InternetConnectionMonitor::startMonitoring() {
 
 void InternetConnectionMonitor::stopMonitoring() {
     ACSDK_DEBUG5(LX(__func__));
+    m_isShuttingDown = true;
     m_connectionTestTimer.stop();
 }
 
@@ -121,39 +131,56 @@ void InternetConnectionMonitor::testConnection() {
 
     auto contentFetcher = m_contentFetcherFactory->create(S3_TEST_URL);
     auto httpContent = contentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
-    if (!httpContent) {
-        ACSDK_ERROR(LX("testConnectionFailed").d("reason", "nullHTTPContentReceived"));
+
+    auto stream = std::make_shared<InProcessAttachment>(PROCESS_ATTACHMENT_ID_PREFIX + S3_TEST_URL);
+    std::shared_ptr<AttachmentWriter> streamWriter = stream->createWriter(WriterPolicy::BLOCKING);
+
+    HTTPContentFetcherInterface::Header header = contentFetcher->getHeader(&m_isShuttingDown);
+
+    if (!header.successful) {
+        ACSDK_ERROR(LX("testConnectionFailed").d("reason", "contentFetcherCouldNotDownloadHeader"));
         updateConnectionStatus(false);
         return;
     }
-    if (!httpContent->isReady(std::chrono::duration_cast<std::chrono::milliseconds>(m_period))) {
-        ACSDK_ERROR(LX("testConnectionFailed").d("reason", "getHttpContentTimeout"));
-        updateConnectionStatus(false);
+
+    ACSDK_DEBUG9(LX(__func__).d("contentLength", header.contentLength));
+
+    contentFetcher->getBody(streamWriter);
+
+    HTTPContentFetcherInterface::State contentFetcherState = contentFetcher->getState();
+    while (!m_isShuttingDown && (HTTPContentFetcherInterface::State::BODY_DONE != contentFetcherState) &&
+           (HTTPContentFetcherInterface::State::ERROR != contentFetcherState)) {
+        std::this_thread::sleep_for(WAIT_FOR_ACTIVITY_TIMEOUT);
+        contentFetcherState = contentFetcher->getState();
+    }
+    if (m_isShuttingDown) {
         return;
     }
-    if (!httpContent->isStatusCodeSuccess()) {
-        ACSDK_ERROR(LX("testConnectionFailed")
-                        .d("reason", "badHTTPContentReceived")
-                        .d("statusCode", httpContent->getStatusCode()));
+    if (HTTPContentFetcherInterface::State::ERROR == contentFetcherState) {
+        ACSDK_ERROR(LX("testConnectionFailed").d("reason", "contentFetcherCouldNotDownloadBody"));
         updateConnectionStatus(false);
         return;
     }
 
-    auto reader = httpContent->getDataStream()->createReader(sds::ReaderPolicy::BLOCKING);
+    std::unique_ptr<AttachmentReader> reader = stream->createReader(ReaderPolicy::NONBLOCKING);
+
     if (!reader) {
         ACSDK_ERROR(LX("testConnectionFailed").d("reason", "failedToCreateStreamReader"));
+        updateConnectionStatus(false);
         return;
     }
     auto readStatus = avs::attachment::AttachmentReader::ReadStatus::OK;
     std::string testContent;
     std::vector<char> buffer(CHUNK_SIZE, 0);
     bool streamClosed = false;
-    while (!streamClosed) {
-        auto bytesRead = reader->read(buffer.data(), buffer.size(), &readStatus);
+    ssize_t bytesReadSoFar = 0;
+    while (!m_isShuttingDown && !streamClosed && (bytesReadSoFar < header.contentLength)) {
+        size_t bytesRead = reader->read(buffer.data(), buffer.size(), &readStatus);
+        bytesReadSoFar += bytesRead;
         switch (readStatus) {
             case avs::attachment::AttachmentReader::ReadStatus::CLOSED:
                 streamClosed = true;
-                if (bytesRead == 0) {
+                if (0 == bytesRead) {
                     break;
                 }
             /* FALL THROUGH - to add any data received even if closed */
@@ -173,8 +200,13 @@ void InternetConnectionMonitor::testConnection() {
                 updateConnectionStatus(false);
                 return;
         }
+        if (bytesReadSoFar >= header.contentLength) {
+            ACSDK_DEBUG9(LX(__func__).m("alreadyReadAllBytes"));
+        }
     }
 
+    ACSDK_DEBUG9(LX(__func__).m("Finished reading"));
+
     // Check that the HTTP content received is what we expected.
     bool found = (testContent.find(VALIDATION_STRING) != std::string::npos);
     updateConnectionStatus(found);
diff --git a/AVSCommon/Utils/test/MIMEParserTest.cpp b/AVSCommon/Utils/test/MIMEParserTest.cpp
index 00046fc..3bf37e1 100644
--- a/AVSCommon/Utils/test/MIMEParserTest.cpp
+++ b/AVSCommon/Utils/test/MIMEParserTest.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -24,11 +24,11 @@
 #include <gmock/gmock.h>
 
 #include "AVSCommon/Utils/Common/Common.h"
+#include "AVSCommon/Utils/HTTP/HttpResponseCode.h"
 #include "AVSCommon/Utils/HTTP2/HTTP2MimeRequestEncoder.h"
 #include "AVSCommon/Utils/HTTP2/HTTP2MimeResponseDecoder.h"
 #include "AVSCommon/Utils/HTTP2/MockHTTP2MimeRequestEncodeSource.h"
 #include "AVSCommon/Utils/HTTP2/MockHTTP2MimeResponseDecodeSink.h"
-#include "AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h"
 #include "AVSCommon/Utils/Logger/LoggerUtils.h"
 
 namespace alexaClientSDK {
@@ -36,6 +36,7 @@ namespace avsCommon {
 namespace test {
 
 using namespace testing;
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::http2;
 using namespace avsCommon::utils;
 using namespace avsCommon::utils::logger;
@@ -290,7 +291,8 @@ void runCodecTest(
     const std::string boundaryHeader{BOUNDARY_HEADER_PREFIX + boundary};
     bool resp = decoder.onReceiveHeaderLine(boundaryHeader);
     ASSERT_TRUE(resp);
-    decoder.onReceiveResponseCode(HTTPResponseCode::SUCCESS_OK);
+    decoder.onReceiveResponseCode(
+        static_cast<std::underlying_type<HTTPResponseCode>::type>(HTTPResponseCode::SUCCESS_OK));
     while ((status == HTTP2ReceiveDataStatus::SUCCESS || status == HTTP2ReceiveDataStatus::PAUSE) &&
            index < finalSize) {
         auto sizeToSend = (index + bufferSize) > finalSize ? finalSize - index : bufferSize;
@@ -431,7 +433,8 @@ TEST_F(MIMEParserTest, duplicateBoundaries) {
     size_t index{0};
     HTTP2ReceiveDataStatus status{HTTP2ReceiveDataStatus::SUCCESS};
     bool resp = decoder.onReceiveHeaderLine(boundaryHeader);
-    decoder.onReceiveResponseCode(HTTPResponseCode::SUCCESS_OK);
+    decoder.onReceiveResponseCode(
+        static_cast<std::underlying_type<HTTPResponseCode>::type>(HTTPResponseCode::SUCCESS_OK));
     while (status == HTTP2ReceiveDataStatus::SUCCESS && index < testPayload.size()) {
         auto sizeToSend = (index + bufferSize) > testPayload.size() ? testPayload.size() - index : bufferSize;
         status = decoder.onReceiveData(testPayload.c_str() + index, sizeToSend);
@@ -479,7 +482,8 @@ TEST_F(MIMEParserTest, testABORT) {
 
     // setup decoder
     HTTP2MimeResponseDecoder decoder{sink};
-    decoder.onReceiveResponseCode(HTTPResponseCode::SUCCESS_OK);
+    decoder.onReceiveResponseCode(
+        static_cast<std::underlying_type<HTTPResponseCode>::type>(HTTPResponseCode::SUCCESS_OK));
     // Ensure repeated calls return ABORT
     ASSERT_EQ(decoder.onReceiveData(encodedPayload.c_str(), SMALL), HTTP2ReceiveDataStatus::ABORT);
     sink->m_abort = false;
@@ -575,7 +579,8 @@ TEST_F(MIMEParserTest, testVariableChunkSizes) {
     HTTP2ReceiveDataStatus status{HTTP2ReceiveDataStatus::SUCCESS};
     const std::string boundaryHeader{BOUNDARY_HEADER_PREFIX + boundary};
     bool resp = decoder.onReceiveHeaderLine(boundaryHeader);
-    decoder.onReceiveResponseCode(HTTPResponseCode::SUCCESS_OK);
+    decoder.onReceiveResponseCode(
+        static_cast<std::underlying_type<HTTPResponseCode>::type>(HTTPResponseCode::SUCCESS_OK));
     ASSERT_TRUE(resp);
     while ((status == HTTP2ReceiveDataStatus::SUCCESS || status == HTTP2ReceiveDataStatus::PAUSE) &&
            index < finalSize) {
@@ -612,7 +617,8 @@ static void testPrefixCase(
     HTTP2MimeResponseDecoder decoder{sink};
 
     ASSERT_TRUE(decoder.onReceiveHeaderLine(BOUNDARY_HEADER_PREFIX + MIME_TEST_BOUNDARY_STRING));
-    ASSERT_TRUE(decoder.onReceiveResponseCode(HTTPResponseCode::SUCCESS_OK));
+    ASSERT_TRUE(decoder.onReceiveResponseCode(
+        static_cast<std::underlying_type<HTTPResponseCode>::type>(HTTPResponseCode::SUCCESS_OK)));
 
     std::string data = prefix + BOUNDARY + MIME_NEWLINE + NORMAL_LINES + MIME_BOUNDARY_DASHES;
     auto writeQuantum = data.length();
diff --git a/CMakeLists.txt b/CMakeLists.txt
index cfdfc5a..957ab1c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,6 +6,10 @@ set(PROJECT_BRIEF "A cross-platform, modular SDK for interacting with the Alexa
 if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayerAdapters")
     set(HAS_EXTERNAL_MEDIA_PLAYER_ADAPTERS ON)
 endif()
+option(EXTERNALMEDIAPLAYER_1_1 "Build ExternalMediaPlayer 1.1" ON)
+if(EXTERNALMEDIAPLAYER_1_1)
+    add_definitions(-DEXTERNALMEDIAPLAYER_1_1)
+endif()
 
 include(build/BuildDefaults.cmake)
 include(tools/Testing.cmake)
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
index e23f573..5eb5811 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
@@ -101,6 +101,12 @@ public:
     void clearData() override;
     /// @}
 
+    // publish capabilities again in case of new client login to same device
+    void setCapabilitiesPublishOverride( bool overriden );
+
+    // set capabilities api endpoint
+    void setCapabilitiesApiEndpoint( std::string& endpoint );
+
 private:
     /**
      * CapabilitiesDelegate constructor.
@@ -300,6 +306,9 @@ private:
     /// To indicate if CapabilitiesDelegate is being shutdown
     bool m_isCapabilitiesDelegateShutdown;
 
+    /// To indicate if CapabilitiesDelegate should publish anyway ( in case of same capabilities with new user account )
+    bool m_capabilitiesDelegatePublishOverride;
+
     /// Used to let CapabilitiesDelegate know that it no longer needs to wait to publish.
     std::condition_variable m_publishWaitDone;
 
diff --git a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
index b343c7e..b71fe4d 100644
--- a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
+++ b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -30,9 +30,9 @@
 #include <AVSCommon/SDKInterfaces/AuthDelegateInterface.h>
 #include <AVSCommon/SDKInterfaces/Storage/MiscStorageInterface.h>
 #include <AVSCommon/Utils/DeviceInfo.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/LibcurlUtils/HttpPutInterface.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
 #include <AVSCommon/Utils/LibcurlUtils/LibcurlUtils.h>
 
@@ -41,6 +41,7 @@ namespace capabilitiesDelegate {
 
 using namespace avsCommon::avs;
 using namespace avsCommon::utils;
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::configuration;
 using namespace avsCommon::utils::libcurlUtils;
 using namespace avsCommon::sdkInterfaces;
@@ -384,7 +385,8 @@ CapabilitiesDelegate::CapabilitiesDelegate(
         m_httpPut{httpPut},
         m_deviceInfo{deviceInfo},
         m_currentAuthState{AuthObserverInterface::State::UNINITIALIZED},
-        m_isCapabilitiesDelegateShutdown{false} {
+        m_isCapabilitiesDelegateShutdown{false},
+        m_capabilitiesDelegatePublishOverride{false} {
 }
 
 void CapabilitiesDelegate::doShutdown() {
@@ -412,11 +414,12 @@ void CapabilitiesDelegate::clearData() {
                                 .d("reason",
                                    "Unable to clear the table " + CAPABILITIES_PUBLISH_TABLE + " for component " +
                                        COMPONENT_NAME + ". Please clear the table for proper future functioning."));
-            } else if (!m_miscStorage->deleteTable(COMPONENT_NAME, CAPABILITIES_PUBLISH_TABLE)) {
+                if (!m_miscStorage->deleteTable(COMPONENT_NAME, CAPABILITIES_PUBLISH_TABLE)) {
                 ACSDK_ERROR(LX("clearDataFailed")
                                 .d("reason",
                                    "Unable to delete the table " + CAPABILITIES_PUBLISH_TABLE + " for component " +
                                        COMPONENT_NAME + ". Please delete the table for proper future functioning."));
+                }
             }
         }
     } else {
@@ -584,19 +587,19 @@ CapabilitiesDelegate::CapabilitiesPublishReturnCode CapabilitiesDelegate::publis
             setCapabilitiesState(
                 CapabilitiesObserverInterface::State::SUCCESS, CapabilitiesObserverInterface::Error::SUCCESS);
             return CapabilitiesDelegate::CapabilitiesPublishReturnCode::SUCCESS;
-        case HTTPResponseCode::BAD_REQUEST:
+        case HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST:
             ACSDK_ERROR(
                 LX(errorEvent).d(errorReasonKey, "badRequest: " + getErrorMsgFromHttpResponse(httpResponse.body)));
             setCapabilitiesState(
                 CapabilitiesObserverInterface::State::FATAL_ERROR, CapabilitiesObserverInterface::Error::BAD_REQUEST);
             return CapabilitiesDelegate::CapabilitiesPublishReturnCode::FATAL_ERROR;
-        case HTTPResponseCode::FORBIDDEN:
+        case HTTPResponseCode::CLIENT_ERROR_FORBIDDEN:
             ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "authenticationFailed"));
             setCapabilitiesState(
                 CapabilitiesObserverInterface::State::FATAL_ERROR, CapabilitiesObserverInterface::Error::FORBIDDEN);
             m_authDelegate->onAuthFailure(authToken);
             return CapabilitiesDelegate::CapabilitiesPublishReturnCode::FATAL_ERROR;
-        case HTTPResponseCode::SERVER_INTERNAL_ERROR:
+        case HTTPResponseCode::SERVER_ERROR_INTERNAL:
             ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "internalServiceError"));
             setCapabilitiesState(
                 CapabilitiesObserverInterface::State::RETRIABLE_ERROR,
@@ -1054,6 +1057,11 @@ void CapabilitiesDelegate::getPreviouslySentCapabilitiesPublishData() {
 bool CapabilitiesDelegate::isCapabilitiesPublishDataDifferent() {
     getPreviouslySentCapabilitiesPublishData();
 
+    // explicitly set overidden
+    if ( m_capabilitiesDelegatePublishOverride ) {
+        return true;
+    }
+
     if ((!m_previousDeviceInfo) || (*m_previousDeviceInfo != *m_deviceInfo)) {
         return true;
     }
@@ -1189,5 +1197,18 @@ void CapabilitiesDelegate::invalidateCapabilities() {
     }
 }
 
+void CapabilitiesDelegate::setCapabilitiesPublishOverride( bool overriden ) {
+    ACSDK_DEBUG0(LX("setCapabilitiesPublishOverride")
+                   .m("overriding capabilities publish"));
+    if (overriden) m_capabilitiesState = CapabilitiesObserverInterface::State::UNINITIALIZED;
+    m_capabilitiesDelegatePublishOverride = overriden;
+}
+
+void CapabilitiesDelegate::setCapabilitiesApiEndpoint( std::string& endpoint ) {
+    ACSDK_DEBUG0(LX("setCapabilitiesApiEndpoint")
+                   .m("overriding capabilities endpoint"));
+    m_capabilitiesApiEndpoint = endpoint;
+}
+
 }  // namespace capabilitiesDelegate
 }  // namespace alexaClientSDK
diff --git a/CapabilitiesDelegate/test/CapabilitiesDelegateTest.cpp b/CapabilitiesDelegate/test/CapabilitiesDelegateTest.cpp
index aa9ccdf..5be42ca 100644
--- a/CapabilitiesDelegate/test/CapabilitiesDelegateTest.cpp
+++ b/CapabilitiesDelegate/test/CapabilitiesDelegateTest.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@
 #include <rapidjson/writer.h>
 
 #include <AVSCommon/AVS/Initialization/AlexaClientSDKInit.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include "Common/TestableAuthDelegate.h"
 #include "Common/TestableCapabilityProvider.h"
 #include "Common/TestableHttpPut.h"
@@ -36,6 +36,7 @@ using namespace avsCommon::avs;
 using namespace avsCommon::avs::initialization;
 using namespace avsCommon::sdkInterfaces;
 using namespace avsCommon::utils;
+using namespace avsCommon::utils::http;
 using namespace avsCommon::utils::configuration;
 using namespace avsCommon::utils::libcurlUtils;
 
@@ -431,7 +432,7 @@ TEST_F(CapabilitiesDelegateTest, publishFatalError) {
     capabilityProvider->addCapabilityConfiguration(INTERFACE_TYPE, INTERFACE_NAME_ONE, INTERFACE_VERSION);
 
     ASSERT_TRUE(m_capabilitiesDelegate->registerCapability(capabilityProvider));
-    m_httpPut->setResponseCode(HTTPResponseCode::BAD_REQUEST);  /// Fatal error
+    m_httpPut->setResponseCode(HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST);  /// Fatal error
     ASSERT_EQ(
         m_capabilitiesDelegate->publishCapabilities(),
         CapabilitiesDelegate::CapabilitiesPublishReturnCode::FATAL_ERROR);
@@ -445,7 +446,7 @@ TEST_F(CapabilitiesDelegateTest, publishRetriableError) {
     capabilityProvider->addCapabilityConfiguration(INTERFACE_TYPE, INTERFACE_NAME_ONE, INTERFACE_VERSION);
 
     ASSERT_TRUE(m_capabilitiesDelegate->registerCapability(capabilityProvider));
-    m_httpPut->setResponseCode(HTTPResponseCode::SERVER_INTERNAL_ERROR);  /// Retriable error
+    m_httpPut->setResponseCode(HTTPResponseCode::SERVER_ERROR_INTERNAL);  /// Retriable error
     ASSERT_EQ(
         m_capabilitiesDelegate->publishCapabilities(),
         CapabilitiesDelegate::CapabilitiesPublishReturnCode::RETRIABLE_ERROR);
diff --git a/CapabilitiesDelegate/test/Common/TestableHttpPut.cpp b/CapabilitiesDelegate/test/Common/TestableHttpPut.cpp
index 1f58010..e4c60bf 100644
--- a/CapabilitiesDelegate/test/Common/TestableHttpPut.cpp
+++ b/CapabilitiesDelegate/test/Common/TestableHttpPut.cpp
@@ -15,13 +15,13 @@
 
 #include "TestableHttpPut.h"
 
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 
 namespace alexaClientSDK {
 namespace capabilitiesDelegate {
 namespace test {
 
-using namespace avsCommon::utils::libcurlUtils;
+using namespace avsCommon::utils::http;
 
 TestHttpPut::TestHttpPut() : m_httpResponseCode{HTTPResponseCode::HTTP_RESPONSE_CODE_UNDEFINED} {
 }
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
index 3eb418f..c89c38c 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
@@ -65,6 +65,29 @@ public:
      */
     virtual void onAlertStateChange(const std::string& alertToken, State state, const std::string& reason = "") = 0;
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    virtual void onAlertCreated(const std::string& alertToken, const std::string& detailedInfo) {};
+
+    /**
+     * A callback function to notify an object that an alert has been deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    virtual void onAlertDeleted(const std::string& alertToken) {};
+
     /**
      * Convert a @c State to a @c std::string.
      *
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
index ba34afa..c83f3c5 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
@@ -269,6 +269,32 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason);
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    void executeOnAlertCreated(
+        const std::string& alertToken,
+        const std::string& jsonPayload);
+
+    /**
+     * A handler function which will be called by our internal executor when an alert is deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    void executeOnAlertDeleted(
+        const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to add an alert observer.
      *
@@ -295,6 +321,21 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason = "");
 
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of detailed alert info.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     * @param jsonInfo The detailed JSON info. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertCreatedObservers(const std::string& alertToken, const std::string& jsonInfo);
+
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of an alert deleted.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertDeletedObservers(const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to remove all alerts currently being managed.
      */
diff --git a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
index 4d86b5c..85edb47 100644
--- a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
+++ b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
@@ -59,6 +59,9 @@ static const std::string ALERTS_CAPABILITY_INTERFACE_VERSION = "1.3";
 /// The value for Type which we need for json parsing.
 static const std::string KEY_TYPE = "type";
 
+/// The value for Label which we need for json parsing.
+static const std::string KEY_LABEL = "label";
+
 // ==== Directives ===
 
 /// The value of the SetAlert Directive.
@@ -457,6 +460,27 @@ bool AlertsCapabilityAgent::handleSetAlert(
 
     updateContextManager();
 
+    Document document( rapidjson::kObjectType );;
+    document.AddMember("time", parsedAlert->getScheduledTime_ISO_8601(), document.GetAllocator());
+    document.AddMember("type", parsedAlert->getTypeName(), document.GetAllocator());
+    std::string label;
+    if (!retrieveValue(payload, KEY_LABEL, &label)) {
+        document.AddMember("label", "", document.GetAllocator());
+    } else {
+        document.AddMember("label", label, document.GetAllocator());
+    }
+    // build the json state string
+    rapidjson::StringBuffer buffer;
+    rapidjson::Writer<rapidjson::StringBuffer> writer( buffer );
+
+    if (!document.Accept( writer )) {
+        ACSDK_ERROR(LX("failedToWriteJsonDocument").m("Alert DetailedInfo not sent"));
+    } else {
+        std::string payload = buffer.GetString();
+        std::string token = parsedAlert->getToken();
+        m_executor.submit([this, token, payload]() { executeOnAlertCreated( token, payload); });
+    }
+
     return true;
 }
 
@@ -476,6 +500,9 @@ bool AlertsCapabilityAgent::handleDeleteAlert(
 
     updateContextManager();
 
+    std::string token = *alertToken;
+    m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
+
     return true;
 }
 
@@ -505,6 +532,8 @@ bool AlertsCapabilityAgent::handleDeleteAlerts(
         if (!convertToValue(tokenArray[i], &token)) {
             ACSDK_WARN(LX("handleDeleteAlertsFailed").d("reason", "invalid token in payload"));
             continue;
+        } else {
+            m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
         }
         alertTokens.push_back(token);
     }
@@ -835,6 +864,14 @@ void AlertsCapabilityAgent::executeOnAlertStateChange(
     m_executor.submit([this, alertToken, state, reason]() { executeNotifyObservers(alertToken, state, reason); });
 }
 
+void AlertsCapabilityAgent::executeOnAlertCreated(const std::string& alertToken, const std::string& payload){
+    m_executor.submit([this, alertToken, payload]() { executeNotifyAlertCreatedObservers(alertToken, payload); });
+}
+
+void AlertsCapabilityAgent::executeOnAlertDeleted(const std::string& alertToken){
+    m_executor.submit([this, alertToken]() { executeNotifyAlertDeletedObservers(alertToken); });
+}
+
 void AlertsCapabilityAgent::executeAddObserver(std::shared_ptr<AlertObserverInterface> observer) {
     ACSDK_DEBUG1(LX("executeAddObserver").d("observer", observer.get()));
     m_observers.insert(observer);
@@ -855,6 +892,23 @@ void AlertsCapabilityAgent::executeNotifyObservers(
     }
 }
 
+void AlertsCapabilityAgent::executeNotifyAlertCreatedObservers(
+    const std::string& alertToken,
+    const std::string& payload) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertCreatedObservers").d("alertToken", alertToken).sensitive("payload", payload));
+    for (auto observer : m_observers) {
+        observer->onAlertCreated(alertToken, payload);
+    }
+}
+
+void AlertsCapabilityAgent::executeNotifyAlertDeletedObservers(
+    const std::string& alertToken) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertDeletedObservers").d("alertToken", alertToken));
+    for (auto observer : m_observers) {
+        observer->onAlertDeleted(alertToken);
+    }
+}
+
 void AlertsCapabilityAgent::executeRemoveAllAlerts() {
     ACSDK_DEBUG1(LX("executeRemoveAllAlerts"));
     m_alertScheduler.clearData();
diff --git a/CapabilityAgents/AudioPlayer/src/ProgressTimer.cpp b/CapabilityAgents/AudioPlayer/src/ProgressTimer.cpp
index 20e2ea7..fb51a3b 100644
--- a/CapabilityAgents/AudioPlayer/src/ProgressTimer.cpp
+++ b/CapabilityAgents/AudioPlayer/src/ProgressTimer.cpp
@@ -251,6 +251,11 @@ void ProgressTimer::mainLoop() {
 
     std::unique_lock<std::mutex> stateLock(m_stateMutex);
 
+    if (NO_DELAY == m_delay && NO_INTERVAL == m_interval) {
+        ACSDK_DEBUG5(LX("mainLoopExiting").d("reason", "noDelayOrInterval"));
+        return;
+    }
+
     while (State::RUNNING == m_state) {
         stateLock.unlock();
         m_gotProgress = false;
@@ -318,8 +323,11 @@ bool ProgressTimer::updateTargetLocked() {
 
     // Handle reporting progress after an initial delay, and without reporting periodic progress.
     if (NO_INTERVAL == m_interval) {
-        // If progress has already reached the initial delay target, there are no more targets...
+        // If progress has already reached the initial delay and there is no interval, there is
+        // no more progress to report and mainLoop() will exit.  Reset m_delay before returning
+        // so that a pesky call to resume() won't trigger more progress reports.
         if (m_target == m_delay) {
+            m_delay = NO_DELAY;
             return false;
         }
 
diff --git a/CapabilityAgents/AudioPlayer/test/ProgressTimerTest.cpp b/CapabilityAgents/AudioPlayer/test/ProgressTimerTest.cpp
index 9841764..fc36d8c 100644
--- a/CapabilityAgents/AudioPlayer/test/ProgressTimerTest.cpp
+++ b/CapabilityAgents/AudioPlayer/test/ProgressTimerTest.cpp
@@ -207,7 +207,7 @@ TEST_F(ProgressTimerTest, testJustInterval) {
     EXPECT_CALL(*(m_mockContext.get()), onProgressReportDelayElapsed()).Times(0);
     EXPECT_CALL(*(m_mockContext.get()), onProgressReportIntervalElapsed()).WillRepeatedly(Invoke(notifyOnTenReports));
 
-    m_timer.init(m_mockContext, ProgressTimer::NO_INTERVAL, MILLIS_10);
+    m_timer.init(m_mockContext, ProgressTimer::NO_DELAY, MILLIS_10);
 
     play();
     ASSERT_TRUE(gotTenReports.waitFor(FAIL_TIMEOUT));
@@ -300,6 +300,25 @@ TEST_F(ProgressTimerTest, testPause) {
     stop();
 }
 
+// Verify that when resumed, a ProgressTimer will not repeat delay progress reports.
+TEST_F(ProgressTimerTest, testResumeDoesNotRepeat) {
+    auto requestProgress = [this] { callOnProgress(); };
+
+    EXPECT_CALL(*(m_mockContext.get()), requestProgress()).WillRepeatedly(Invoke(requestProgress));
+    EXPECT_CALL(*(m_mockContext.get()), onProgressReportDelayElapsed()).Times(1);
+    EXPECT_CALL(*(m_mockContext.get()), onProgressReportIntervalElapsed()).Times(0);
+
+    m_timer.init(m_mockContext, MILLIS_10, ProgressTimer::NO_INTERVAL);
+
+    play();
+    std::this_thread::sleep_for(MILLIS_100);
+    pause();
+    std::this_thread::sleep_for(MILLIS_100);
+    resume();
+    std::this_thread::sleep_for(MILLIS_100);
+    stop();
+}
+
 // Verify that the generated offsets are approximately correct.
 TEST_F(ProgressTimerTest, testOffsets) {
     auto requestProgress = [this] { callOnProgress(); };
diff --git a/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h b/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h
index e7919eb..3bfab0a 100644
--- a/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h
+++ b/CapabilityAgents/ExternalMediaPlayer/include/ExternalMediaPlayer/ExternalMediaPlayer.h
@@ -20,6 +20,11 @@
 #include <memory>
 #include <string>
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/AVS/PlayerActivity.h>
+#include <AVSCommon/SDKInterfaces/ExternalMediaAdapterHandlerInterface.h>
+#endif
 #include <AVSCommon/AVS/CapabilityAgent.h>
 #include <AVSCommon/AVS/DirectiveHandlerConfiguration.h>
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
@@ -41,6 +46,23 @@ namespace alexaClientSDK {
 namespace capabilityAgents {
 namespace externalMediaPlayer {
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/// Enum to identify the initiator type of a stop.
+enum class HaltInitiator {
+    /// The system is not halted.
+    NONE,
+
+    /// Voice initiated Pause request from AVS/Pause from Spotify Connect.
+    EXTERNAL_PAUSE,
+
+    /// Pause was initiated when focus changed from FOREGROUND to BACKGROUND.
+    FOCUS_CHANGE_PAUSE,
+
+    /// Stop initiated when focus changed from FOREGROUND/BACKGROUND to NONE.
+    FOCUS_CHANGE_STOP
+};
+#endif
+
 /**
  * This class implements the @c ExternalMediaPlayer capability agent. This agent is responsible for handling
  * music service providers which manage their PLAY queue.
@@ -104,6 +126,21 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    void addAdapterHandler(std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler);
+    void removeAdapterHandler(std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler);
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    void executeOnFocusChanged(avsCommon::avs::FocusState newFocus);
+
+    void onFocusChanged(avsCommon::avs::FocusState newFocus) override;
+
+    void onContextAvailable(const std::string& jsonContext) override;
+
+    void onContextFailure(const avsCommon::sdkInterfaces::ContextRequestError error) override;
+#endif
+
     /// @name StateProviderInterface Functions
     /// @{
     void provideState(const avsCommon::avs::NamespaceAndName& stateProviderName, unsigned int stateRequestToken)
@@ -129,6 +166,12 @@ public:
 
     /// @name Overridden ExternalMediaPlayerInterface methods.
     /// @{
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    virtual void setCurrentActivity(const avsCommon::avs::PlayerActivity currentActivity) override;
+
+    virtual void setPlayerInFocus(const std::string& playerInFocus, bool focusAcquire) override;
+#endif
+
     virtual void setPlayerInFocus(const std::string& playerInFocus) override;
     /// @}
 
@@ -174,12 +217,20 @@ private:
     /**
      * This method returns the ExternalMediaPlayer session state registered in the ExternalMediaPlayer namespace.
      */
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::string provideSessionState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates);
+#else
     std::string provideSessionState();
+#endif
 
     /**
      * This method returns the Playback state registered in the Alexa.PlaybackStateReporter state.
      */
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::string providePlaybackState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates);
+#else
     std::string providePlaybackState();
+#endif
 
     /**
      * This function deserializes a @c Directive's payload into a @c rapidjson::Document.
@@ -222,6 +273,15 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Set the appropriate halt initiator for the request.
+     *
+     * @param The type of the request.
+     */
+    void setHaltInitiatorRequestHelper(avsCommon::sdkInterfaces::externalMediaPlayer::RequestType request);
+#endif
+
     /**
      * Send the handling completed notification and clean up the resources the specified @c DirectiveInfo.
      *
@@ -278,6 +338,19 @@ private:
         std::shared_ptr<DirectiveInfo> info,
         rapidjson::Document* document);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /**
+     * Handler for AuthorizeDiscoveredPlayers directive.
+     *
+     * @param info The DirectiveInfo to be processed.
+     * @param The type of the request. Will be NONE for the
+     *        handleAuthorizeDiscoveredPlayers case.
+     */
+    void handleAuthorizeDiscoveredPlayers(
+        std::shared_ptr<DirectiveInfo> info,
+        avsCommon::sdkInterfaces::externalMediaPlayer::RequestType request);
+#endif
+
     /**
      * Handler for login directive.
      *
@@ -394,6 +467,33 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::externalMediaPlayer::ExternalMediaPlayerObserverInterface>>
         m_observers;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface>> m_adapterHandlers;
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    /// The @c FocusManager used to manage usage of the channel.
+    std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> m_focusManager;
+
+    /// The current focus state of the @c AudioPlayer on the content channel.
+    avsCommon::avs::FocusState m_focus;
+
+    /// bool to identify if acquire of focus is currently in progress.
+    bool m_focusAcquireInProgress;
+
+    /// Enum to identify the type and source of the halt request.
+    HaltInitiator m_haltInitiator;
+
+    /// The current state of the @c ExternalMediaPlayer.
+    avsCommon::avs::PlayerActivity m_currentActivity;
+
+    /// Protects writes to @c m_currentActivity and waiting on @c m_currentActivityConditionVariable.
+    std::mutex m_currentActivityMutex;
+
+    /// Provides notifications of changes to @c m_currentActivity.
+    std::condition_variable m_currentActivityConditionVariable;
+#endif
+
     /**
      * @c Executor which queues up operations from asynchronous API calls.
      *
diff --git a/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp b/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp
index 7e6c43a..5af5341 100644
--- a/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp
+++ b/CapabilityAgents/ExternalMediaPlayer/src/ExternalMediaPlayer.cpp
@@ -75,8 +75,13 @@ static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_TYPE = ALEXA_I
 /// ExternalMediaPlayer interface name
 static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_NAME = "ExternalMediaPlayer";
 /// ExternalMediaPlayer interface version
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_VERSION = "1.1";
+#else
 static const std::string EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_VERSION = "1.0";
+#endif
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
 /// Alexa.PlaybackStateReporter name.
 static const std::string PLAYBACKSTATEREPORTER_CAPABILITY_INTERFACE_NAME = PLAYBACKSTATEREPORTER_STATE_NAMESPACE;
 /// Alexa.PlaybackStateReporter version.
@@ -101,11 +106,30 @@ static const std::string SEEKCONTROLLER_CAPABILITY_INTERFACE_VERSION = "1.0";
 static const std::string FAVORITESCONTROLLER_CAPABILITY_INTERFACE_NAME = FAVORITESCONTROLLER_NAMESPACE;
 /// Alexa.FavoritesController version.
 static const std::string FAVORITESCONTROLLER_CAPABILITY_INTERFACE_VERSION = "1.0";
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/// The name of the @c FocusManager channel used by @c ExternalMediaPlayer and
+/// its Adapters.
+static const std::string CHANNEL_NAME = avsCommon::sdkInterfaces::FocusManagerInterface::CONTENT_CHANNEL_NAME;
+
+/**
+ * The activityId string used with @c FocusManager by @c ExternalMediaPlayer.
+ * (as per spec for AVS for monitoring channel activity.)
+ */
+static const std::string FOCUS_MANAGER_ACTIVITY_ID = "ExternalMediaPlayer";
+
+/// The duration to wait for a state change in @c onFocusChanged before failing.
+static const std::chrono::seconds TIMEOUT{2};
+#endif
 
 // The @c External media player play directive signature.
 static const NamespaceAndName PLAY_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Play"};
 static const NamespaceAndName LOGIN_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Login"};
 static const NamespaceAndName LOGOUT_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Logout"};
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static const NamespaceAndName AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "AuthorizeDiscoveredPlayers"};
+#endif
 
 // The @c Transport control directive signatures.
 static const NamespaceAndName RESUME_DIRECTIVE{PLAYBACKCONTROLLER_NAMESPACE, "Play"};
@@ -157,6 +181,9 @@ static std::shared_ptr<avsCommon::avs::CapabilityConfiguration> getExternalMedia
 /// The @c m_directiveToHandlerMap Map of the directives to their handlers.
 std::unordered_map<NamespaceAndName, std::pair<RequestType, ExternalMediaPlayer::DirectiveHandler>>
     ExternalMediaPlayer::m_directiveToHandlerMap = {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        {AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE, std::make_pair(RequestType::NONE, &ExternalMediaPlayer::handleAuthorizeDiscoveredPlayers)},
+#endif
         {LOGIN_DIRECTIVE, std::make_pair(RequestType::LOGIN, &ExternalMediaPlayer::handleLogin)},
         {LOGOUT_DIRECTIVE, std::make_pair(RequestType::LOGOUT, &ExternalMediaPlayer::handleLogout)},
         {PLAY_DIRECTIVE, std::make_pair(RequestType::PLAY, &ExternalMediaPlayer::handlePlay)},
@@ -182,7 +209,12 @@ std::unordered_map<NamespaceAndName, std::pair<RequestType, ExternalMediaPlayer:
 auto audioNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUM_AUDIO, false);
 auto neitherNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static DirectiveHandlerConfiguration g_configuration = {{AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE, audioNonBlockingPolicy},
+                                                        {PLAY_DIRECTIVE, audioNonBlockingPolicy},
+#else
 static DirectiveHandlerConfiguration g_configuration = {{PLAY_DIRECTIVE, audioNonBlockingPolicy},
+#endif
                                                         {LOGIN_DIRECTIVE, neitherNonBlockingPolicy},
                                                         {LOGOUT_DIRECTIVE, neitherNonBlockingPolicy},
                                                         {RESUME_DIRECTIVE, audioNonBlockingPolicy},
@@ -203,15 +235,21 @@ static DirectiveHandlerConfiguration g_configuration = {{PLAY_DIRECTIVE, audioNo
                                                         {UNFAVORITE_DIRECTIVE, neitherNonBlockingPolicy}};
 
 static std::unordered_map<PlaybackButton, RequestType> g_buttonToRequestType = {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    // Important Note: This changes default AVS Device SDK behavior.
+    {PlaybackButton::PLAY, RequestType::RESUME},
+    {PlaybackButton::PAUSE, RequestType::PAUSE},
+#else
     {PlaybackButton::PLAY, RequestType::PAUSE_RESUME_TOGGLE},
     {PlaybackButton::PAUSE, RequestType::PAUSE_RESUME_TOGGLE},
+#endif
     {PlaybackButton::NEXT, RequestType::NEXT},
     {PlaybackButton::PREVIOUS, RequestType::PREVIOUS}};
 
 static std::unordered_map<PlaybackToggle, std::pair<RequestType, RequestType>> g_toggleToRequestType = {
     {PlaybackToggle::SHUFFLE, std::make_pair(RequestType::ENABLE_SHUFFLE, RequestType::DISABLE_SHUFFLE)},
     {PlaybackToggle::LOOP, std::make_pair(RequestType::ENABLE_REPEAT, RequestType::DISABLE_REPEAT)},
-    {PlaybackToggle::REPEAT, std::make_pair(RequestType::ENABLE_REPEAT_ONE, RequestType::DISABLE_REPEAT_ONE)},
+    {PlaybackToggle::REPEAT, std::make_pair(RequestType::ENABLE_REPEAT_ONE, RequestType::DISABLE_REPEAT)},
     {PlaybackToggle::THUMBS_UP, std::make_pair(RequestType::FAVORITE, RequestType::DESELECT_FAVORITE)},
     {PlaybackToggle::THUMBS_DOWN, std::make_pair(RequestType::UNFAVORITE, RequestType::DESELECT_UNFAVORITE)}};
 
@@ -279,6 +317,10 @@ std::shared_ptr<ExternalMediaPlayer> ExternalMediaPlayer::create(
     externalMediaPlayer->createAdapters(
         mediaPlayers, speakers, adapterCreationMap, messageSender, focusManager, contextManager);
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    externalMediaPlayer->m_focusManager = focusManager;
+#endif
+
     return externalMediaPlayer;
 }
 
@@ -291,10 +333,18 @@ ExternalMediaPlayer::ExternalMediaPlayer(
         RequiresShutdown{"ExternalMediaPlayer"},
         m_speakerManager{speakerManager},
         m_contextManager{contextManager},
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_playbackRouter{playbackRouter},
+        m_focus{FocusState::NONE},
+        m_focusAcquireInProgress{false},
+        m_haltInitiator{HaltInitiator::NONE},
+        m_currentActivity{avsCommon::avs::PlayerActivity::IDLE} {
+#else
         m_playbackRouter{playbackRouter} {
-    // Register all supported capabilities.
+#endif
     m_capabilityConfigurations.insert(getExternalMediaPlayerCapabilityConfiguration());
-
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    // Register all supported capabilities.
     m_capabilityConfigurations.insert(generateCapabilityConfiguration(
         ALEXA_INTERFACE_TYPE,
         PLAYBACKSTATEREPORTER_CAPABILITY_INTERFACE_NAME,
@@ -317,6 +367,7 @@ ExternalMediaPlayer::ExternalMediaPlayer(
         ALEXA_INTERFACE_TYPE,
         FAVORITESCONTROLLER_CAPABILITY_INTERFACE_NAME,
         FAVORITESCONTROLLER_CAPABILITY_INTERFACE_VERSION));
+#endif
 }
 
 std::shared_ptr<CapabilityConfiguration> getExternalMediaPlayerCapabilityConfiguration() {
@@ -326,6 +377,222 @@ std::shared_ptr<CapabilityConfiguration> getExternalMediaPlayerCapabilityConfigu
         EXTERNALMEDIAPLAYER_CAPABILITY_INTERFACE_VERSION);
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::addAdapterHandler(
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler) {
+    ACSDK_DEBUG5(LX("addAdapterHandler"));
+    if (!adapterHandler) {
+        ACSDK_ERROR(LX("addAdapterHandler").m("Adapter handler is null."));
+        return;
+    }
+    m_executor.submit([this, adapterHandler]() {
+        ACSDK_DEBUG5(LX("addAdapterHandlerInExecutor"));
+        if (!m_adapterHandlers.insert(adapterHandler).second) {
+            ACSDK_ERROR(LX("addAdapterHandlerInExecutor").m("Duplicate adapter handler."));
+        }
+    });
+}
+
+void ExternalMediaPlayer::removeAdapterHandler(
+    std::shared_ptr<avsCommon::sdkInterfaces::ExternalMediaAdapterHandlerInterface> adapterHandler) {
+    ACSDK_DEBUG5(LX("removeAdapterHandler"));
+    if (!adapterHandler) {
+        ACSDK_ERROR(LX("removeAdapterHandler").m("Adapter handler is null."));
+        return;
+    }
+    m_executor.submit([this, adapterHandler]() {
+        ACSDK_DEBUG5(LX("removeAdapterHandlerInExecutor"));
+        if (m_adapterHandlers.erase(adapterHandler) == 0) {
+            ACSDK_WARN(LX("removeAdapterHandlerInExecutor").m("Nonexistent adapter handler."));
+        }
+    });
+}
+#endif
+
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::executeOnFocusChanged(avsCommon::avs::FocusState newFocus) {
+    ACSDK_DEBUG1(
+        LX("executeOnFocusChanged").d("from", m_focus).d("to", newFocus).d("m_currentActivity", m_currentActivity));
+    if (m_focus == newFocus) {
+        m_focusAcquireInProgress = false;
+        return;
+    }
+    m_focus = newFocus;
+    m_focusAcquireInProgress = false;
+
+    if (!m_playerInFocus.empty()) {
+        auto adapterIt = m_adapters.find(m_playerInFocus);
+
+        if (m_adapters.end() == adapterIt) {
+            switch (newFocus) {
+                case FocusState::FOREGROUND: {
+                    /*
+                     * If the system is currently in a pause initiated from AVS, on focus change
+                     * to FOREGROUND do not try to resume. This happens when a user calls
+                     * "Alexa, pause" while Spotify is PLAYING. This moves the adapter to
+                     * BACKGROUND focus. AVS then sends a PAUSE request and after calling the
+                     * ESDK pause when the adapter switches to FOREGROUND focus we do not want
+                     * the adapter to start PLAYING.
+                     */
+                    if (m_haltInitiator == HaltInitiator::EXTERNAL_PAUSE) {
+                        return;
+                    }
+
+                    switch (m_currentActivity) {
+                        case PlayerActivity::IDLE:
+                        case PlayerActivity::STOPPED:
+                        case PlayerActivity::FINISHED:
+                            return;
+                        case PlayerActivity::PAUSED: {
+                            // A focus change to foreground when paused means we should resume the current song.
+                            ACSDK_DEBUG1(LX("executeOnFocusChanged").d("action", "resumeExternalMediaPlayer"));
+                            setCurrentActivity(avsCommon::avs::PlayerActivity::PLAYING);
+                            // At this point a request to play another artist on Spotify may have already
+                            // been processed (or is being processed) and we do not want to send resume here.
+                            if (m_haltInitiator != HaltInitiator::NONE) {
+                                for (auto adapterHandler : m_adapterHandlers) {
+                                    adapterHandler->playControlForPlayer(m_playerInFocus, RequestType::RESUME);
+                                }
+                            }
+                        }
+                            return;
+                        case PlayerActivity::PLAYING:
+                        case PlayerActivity::BUFFER_UNDERRUN:
+                            // We should already have foreground focus in these states; break out to the warning below.
+                            break;
+                    }
+                    break;
+                }
+                case FocusState::BACKGROUND:
+                    switch (m_currentActivity) {
+                        case PlayerActivity::STOPPED:
+                        // We can also end up here with an empty queue if we've asked MediaPlayer to play, but playback
+                        // hasn't started yet, so we fall through to call @c pause() here as well.
+                        case PlayerActivity::FINISHED:
+                        case PlayerActivity::IDLE:
+                        // Note: can be in FINISHED or IDLE while waiting for MediaPlayer to start playing, so we fall
+                        // through to call @c pause() here as well.
+                        case PlayerActivity::PAUSED:
+                        // Note: can be in PAUSED while we're trying to resume, in which case we still want to pause, so we
+                        // fall through to call @c pause() here as well.
+                        case PlayerActivity::PLAYING:
+                        case PlayerActivity::BUFFER_UNDERRUN: {
+                            // If we get pushed into the background while playing or buffering, pause the current song.
+                            ACSDK_DEBUG1(LX("executeOnFocusChanged").d("action", "pauseExternalMediaPlayer"));
+                            if (m_haltInitiator != HaltInitiator::EXTERNAL_PAUSE) {
+                                m_haltInitiator = HaltInitiator::FOCUS_CHANGE_PAUSE;
+                            }
+                            setCurrentActivity(avsCommon::avs::PlayerActivity::PAUSED);
+                            for (auto adapterHandler : m_adapterHandlers) {
+                                adapterHandler->playControlForPlayer(m_playerInFocus, RequestType::PAUSE);
+                            }
+                        }
+                            return;
+                    }
+                    break;
+                case FocusState::NONE:
+                    switch (m_currentActivity) {
+                        case PlayerActivity::IDLE:
+                        case PlayerActivity::STOPPED:
+                        case PlayerActivity::FINISHED:
+                            // Nothing to more to do if we're already not playing; we got here because the act of stopping
+                            // caused the channel to be released, which in turn caused this callback.
+                            return;
+                        case PlayerActivity::PLAYING:
+                        case PlayerActivity::PAUSED:
+                        case PlayerActivity::BUFFER_UNDERRUN:
+                            // If the focus change came in while we were in a 'playing' state, we need to stop because we are
+                            // yielding the channel.
+                            ACSDK_DEBUG1(LX("executeOnFocusChanged").d("action", "stopExternalMediaPlayer"));
+                            m_haltInitiator = HaltInitiator::FOCUS_CHANGE_STOP;
+                            setCurrentActivity(avsCommon::avs::PlayerActivity::STOPPED);
+                            for (auto adapterHandler : m_adapterHandlers) {
+                                adapterHandler->playControlForPlayer(m_playerInFocus, RequestType::STOP);
+                            }
+                            return;
+                    }
+                    break;
+            }
+        }
+    }
+    ACSDK_WARN(LX("unexpectedExecuteOnFocusChanged").d("newFocus", newFocus).d("m_currentActivity", m_currentActivity));
+}
+
+void ExternalMediaPlayer::onFocusChanged(FocusState newFocus) {
+    ACSDK_DEBUG(LX("onFocusChanged").d("newFocus", newFocus));
+    m_executor.submit([this, newFocus] { executeOnFocusChanged(newFocus); });
+
+    switch (newFocus) {
+        case FocusState::FOREGROUND:
+            // Could wait for playback to actually start, but there's no real benefit to waiting, and long delays in
+            // buffering could result in timeouts, so returning immediately for this case.
+            return;
+        case FocusState::BACKGROUND: {
+            // Ideally expecting to see a transition to PAUSED, but in terms of user-observable changes, a move to any
+            // of PAUSED/STOPPED/FINISHED will indicate that it's safe for another channel to move to the foreground.
+            auto predicate = [this] {
+                switch (m_currentActivity) {
+                    case PlayerActivity::IDLE:
+                    case PlayerActivity::PAUSED:
+                    case PlayerActivity::STOPPED:
+                    case PlayerActivity::FINISHED:
+                        return true;
+                    case PlayerActivity::PLAYING:
+                    case PlayerActivity::BUFFER_UNDERRUN:
+                        return false;
+                }
+                ACSDK_ERROR(LX("onFocusChangedFailed")
+                                .d("reason", "unexpectedActivity")
+                                .d("m_currentActivity", m_currentActivity));
+                return false;
+            };
+            std::unique_lock<std::mutex> lock(m_currentActivityMutex);
+            if (!m_currentActivityConditionVariable.wait_for(lock, TIMEOUT, predicate)) {
+                ACSDK_ERROR(
+                    LX("onFocusChangedTimedOut").d("newFocus", newFocus).d("m_currentActivity", m_currentActivity));
+            }
+        }
+            return;
+        case FocusState::NONE: {
+            // Need to wait for STOPPED or FINISHED, indicating that we have completely ended playback.
+            auto predicate = [this] {
+                switch (m_currentActivity) {
+                    case PlayerActivity::IDLE:
+                    case PlayerActivity::STOPPED:
+                    case PlayerActivity::FINISHED:
+                        return true;
+                    case PlayerActivity::PLAYING:
+                    case PlayerActivity::PAUSED:
+                    case PlayerActivity::BUFFER_UNDERRUN:
+                        return false;
+                }
+                ACSDK_ERROR(LX("onFocusChangedFailed")
+                                .d("reason", "unexpectedActivity")
+                                .d("m_currentActivity", m_currentActivity));
+                return false;
+            };
+            std::unique_lock<std::mutex> lock(m_currentActivityMutex);
+            if (!m_currentActivityConditionVariable.wait_for(lock, TIMEOUT, predicate)) {
+                ACSDK_ERROR(LX("onFocusChangedFailed")
+                                .d("reason", "activityChangeTimedOut")
+                                .d("newFocus", newFocus)
+                                .d("m_currentActivity", m_currentActivity));
+            }
+        }
+            return;
+    }
+    ACSDK_ERROR(LX("onFocusChangedFailed").d("reason", "unexpectedFocusState").d("newFocus", newFocus));
+}
+
+void ExternalMediaPlayer::onContextAvailable(const std::string&) {
+    // default no-op
+}
+
+void ExternalMediaPlayer::onContextFailure(const avsCommon::sdkInterfaces::ContextRequestError) {
+    // default no-op
+}
+#endif
+
 void ExternalMediaPlayer::provideState(
     const avsCommon::avs::NamespaceAndName& stateProviderName,
     unsigned int stateRequestToken) {
@@ -399,6 +666,12 @@ std::shared_ptr<ExternalMediaAdapterInterface> ExternalMediaPlayer::preprocessDi
         return nullptr;
     }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    if (m_adapters.empty()) { // use handlers when there are no adapters
+        return nullptr;
+    }
+#endif
+
     auto adapterIt = m_adapters.find(playerId);
     if (adapterIt == m_adapters.end()) {
         ACSDK_ERROR(LX("preprocessDirectiveFailed").d("reason", "noAdapterForPlayerId").d(PLAYER_ID, playerId));
@@ -416,11 +689,36 @@ std::shared_ptr<ExternalMediaAdapterInterface> ExternalMediaPlayer::preprocessDi
     return adapter;
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::handleAuthorizeDiscoveredPlayers(std::shared_ptr<DirectiveInfo> info, RequestType request) {
+    rapidjson::Document payload;
+
+    if (!parseDirectivePayload(info, &payload)) {
+        return;
+    }
+
+    m_executor.submit([this, info]() {
+        for (auto adapterHandler : m_adapterHandlers) {
+            adapterHandler->authorizeDiscoveredPlayers(info->directive->getPayload());
+        }
+        setHandlingCompleted(info);
+    });
+}
+#endif
+
 void ExternalMediaPlayer::handleLogin(std::shared_ptr<DirectiveInfo> info, RequestType request) {
     rapidjson::Document payload;
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->login(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -459,6 +757,14 @@ void ExternalMediaPlayer::handleLogout(std::shared_ptr<DirectiveInfo> info, Requ
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->logout(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -471,6 +777,15 @@ void ExternalMediaPlayer::handlePlay(std::shared_ptr<DirectiveInfo> info, Reques
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        setHaltInitiatorRequestHelper(request);
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->play(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -491,8 +806,41 @@ void ExternalMediaPlayer::handlePlay(std::shared_ptr<DirectiveInfo> info, Reques
         index = 0;
     }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::string skillToken;
+    if (!jsonUtils::retrieveValue(payload, "skillToken", &skillToken)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullSkillToken"));
+        sendExceptionEncounteredAndReportFailed(info, "missing skillToken in Play directive");
+        return;
+    }
+
+    std::string playbackSessionId;
+    if (!jsonUtils::retrieveValue(payload, "playbackSessionId", &playbackSessionId)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullPlaybackSessionId"));
+        sendExceptionEncounteredAndReportFailed(info, "missing playbackSessionId in Play directive");
+        return;
+    }
+
+    std::string navigation;
+    if (!jsonUtils::retrieveValue(payload, "navigation", &navigation)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullNavigation"));
+        sendExceptionEncounteredAndReportFailed(info, "missing navigation in Play directive");
+        return;
+    }
+
+    bool preload;
+    if (!jsonUtils::retrieveValue(payload, "preload", &preload)) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullPreload"));
+        sendExceptionEncounteredAndReportFailed(info, "missing preload in Play directive");
+        return;
+    }
+
+    setHandlingCompleted(info);
+    adapter->handlePlay(playbackContextToken, index, std::chrono::milliseconds(offset), skillToken, playbackSessionId, navigation, preload);
+#else
     setHandlingCompleted(info);
     adapter->handlePlay(playbackContextToken, index, std::chrono::milliseconds(offset));
+#endif
 }
 
 void ExternalMediaPlayer::handleSeek(std::shared_ptr<DirectiveInfo> info, RequestType request) {
@@ -500,6 +848,14 @@ void ExternalMediaPlayer::handleSeek(std::shared_ptr<DirectiveInfo> info, Reques
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->seek(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -519,6 +875,14 @@ void ExternalMediaPlayer::handleAdjustSeek(std::shared_ptr<DirectiveInfo> info,
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        m_executor.submit([this, info]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->adjustSeek(info->directive->getPayload());
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -546,6 +910,15 @@ void ExternalMediaPlayer::handlePlayControl(std::shared_ptr<DirectiveInfo> info,
 
     auto adapter = preprocessDirective(info, &payload);
     if (!adapter) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        setHaltInitiatorRequestHelper(request);
+        m_executor.submit([this, info, request]() {
+            for (auto adapterHandler : m_adapterHandlers) {
+                adapterHandler->playControl(info->directive->getPayload(),request);
+            }
+            setHandlingCompleted(info);
+        });
+#endif
         return;
     }
 
@@ -564,6 +937,38 @@ DirectiveHandlerConfiguration ExternalMediaPlayer::getConfiguration() const {
     return g_configuration;
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+
+void ExternalMediaPlayer::setCurrentActivity(const avsCommon::avs::PlayerActivity currentActivity) {
+    ACSDK_DEBUG9(LX("setCurrentActivity").d("from", m_currentActivity).d("to", currentActivity));
+    {
+        std::lock_guard<std::mutex> lock(m_currentActivityMutex);
+        m_currentActivity = currentActivity;
+    }
+    m_currentActivityConditionVariable.notify_all();
+}
+
+void ExternalMediaPlayer::setPlayerInFocus(const std::string& playerInFocus, bool focusAcquire) {
+    ACSDK_DEBUG9(LX("setPlayerInFocus").d("playerInFocus", playerInFocus).d("focusAcquire", focusAcquire ? "true" : "false"));
+    if (focusAcquire) {
+        m_playerInFocus = playerInFocus;
+        m_playbackRouter->setHandler(shared_from_this());
+        // Acquire the channel and have this ExternalMediaPlayer manage the focus state.
+        if (m_focus == FocusState::NONE && m_focusAcquireInProgress != true) {
+            m_currentActivity = avsCommon::avs::PlayerActivity::IDLE;
+            m_haltInitiator = HaltInitiator::NONE;
+            m_focusAcquireInProgress = true;
+            m_focusManager->acquireChannel(CHANNEL_NAME, shared_from_this(), FOCUS_MANAGER_ACTIVITY_ID);
+        }
+    }
+    else if (playerInFocus.compare(m_playerInFocus) == 0 && m_focus != avsCommon::avs::FocusState::NONE) {
+        // We only release the channel when the player is the player in focus.
+        m_focusManager->releaseChannel(CHANNEL_NAME, shared_from_this());
+    }
+}
+
+#endif
+
 void ExternalMediaPlayer::setPlayerInFocus(const std::string& playerInFocus) {
     ACSDK_DEBUG9(LX("setPlayerInFocus").d("playerInFocus", playerInFocus));
     m_playerInFocus = playerInFocus;
@@ -571,19 +976,28 @@ void ExternalMediaPlayer::setPlayerInFocus(const std::string& playerInFocus) {
 }
 
 void ExternalMediaPlayer::onButtonPressed(PlaybackButton button) {
+    auto buttonIt = g_buttonToRequestType.find(button);
+
+    if (g_buttonToRequestType.end() == buttonIt) {
+        ACSDK_ERROR(LX("ButtonToRequestTypeNotFound").d("button", button));
+        return;
+    }
+
     if (!m_playerInFocus.empty()) {
         auto adapterIt = m_adapters.find(m_playerInFocus);
 
         if (m_adapters.end() == adapterIt) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            setHaltInitiatorRequestHelper(buttonIt->second);
+            m_executor.submit([this, buttonIt]() {
+                for (auto adapterHandler : m_adapterHandlers) {
+                    adapterHandler->playControlForPlayer(m_playerInFocus, buttonIt->second);
+                }
+            });
+#else
             // Should never reach here as playerInFocus is always set based on a contract with AVS.
             ACSDK_ERROR(LX("AdapterNotFound").d("player", m_playerInFocus));
-            return;
-        }
-
-        auto buttonIt = g_buttonToRequestType.find(button);
-
-        if (g_buttonToRequestType.end() == buttonIt) {
-            ACSDK_ERROR(LX("ButtonToRequestTypeNotFound").d("button", button));
+#endif
             return;
         }
 
@@ -592,37 +1006,48 @@ void ExternalMediaPlayer::onButtonPressed(PlaybackButton button) {
 }
 
 void ExternalMediaPlayer::onTogglePressed(PlaybackToggle toggle, bool action) {
+    auto toggleIt = g_toggleToRequestType.find(toggle);
+
+    if (g_toggleToRequestType.end() == toggleIt) {
+        ACSDK_ERROR(LX("ToggleToRequestTypeNotFound").d("toggle", toggle));
+        return;
+    }
+
+    // toggleStates map is <SELECTED,DESELECTED>
+    auto toggleStates = toggleIt->second;
+
     if (!m_playerInFocus.empty()) {
         auto adapterIt = m_adapters.find(m_playerInFocus);
 
         if (m_adapters.end() == adapterIt) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            m_executor.submit([this, action, toggleStates]() {
+                for (auto adapterHandler : m_adapterHandlers) {
+                    if (action) {
+                        adapterHandler->playControlForPlayer(m_playerInFocus, toggleStates.first);
+                    }
+                    else {
+                        adapterHandler->playControlForPlayer(m_playerInFocus, toggleStates.second);
+                    }
+                }
+            });
+#else
             // Should never reach here as playerInFocus is always set based on a contract with AVS.
             ACSDK_ERROR(LX("AdapterNotFound").d("player", m_playerInFocus));
+#endif
             return;
         }
 
-        auto toggleIt = g_toggleToRequestType.find(toggle);
-
-        if (g_toggleToRequestType.end() == toggleIt) {
-            ACSDK_ERROR(LX("ToggleToRequestTypeNotFound").d("toggle", toggle));
-            return;
-        }
-
-        auto adapter = adapterIt->second;
-
-        // toggleStates map is <SELECTED,DESELECTED>
-        auto toggleStates = toggleIt->second;
-
-        if (action) {
-            adapter->handlePlayControl(toggleStates.first);
-        } else {
-            adapterIt->second->handlePlayControl(toggleStates.second);
-        }
+        adapterIt->second->handlePlayControl(action ? toggleStates.first : toggleStates.second);
     }
 }
 
 void ExternalMediaPlayer::doShutdown() {
     m_executor.shutdown();
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    m_adapterHandlers.clear();
+    m_focusManager.reset();
+#endif
     // Reset the EMP from being a state provider. If not there would be calls from the adapter to provide context
     // which will try to add tasks to the executor thread.
     m_contextManager->setStateProvider(SESSION_STATE, nullptr);
@@ -650,6 +1075,29 @@ void ExternalMediaPlayer::removeDirective(std::shared_ptr<DirectiveInfo> info) {
     }
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+void ExternalMediaPlayer::setHaltInitiatorRequestHelper(RequestType request) {
+    switch (request) {
+        case RequestType::PAUSE:
+            m_haltInitiator = HaltInitiator::EXTERNAL_PAUSE;
+            break;
+        case RequestType::PAUSE_RESUME_TOGGLE:
+            if (m_currentActivity == avsCommon::avs::PlayerActivity::PLAYING ||
+                    (m_currentActivity == avsCommon::avs::PlayerActivity::PAUSED &&
+                    m_haltInitiator == HaltInitiator::FOCUS_CHANGE_PAUSE)) {
+                m_haltInitiator = HaltInitiator::EXTERNAL_PAUSE;
+            }
+            break;
+        case RequestType::PLAY:
+        case RequestType::RESUME:
+            m_haltInitiator = HaltInitiator::NONE;
+            break;
+        default:
+            break;
+    }
+}
+#endif
+
 void ExternalMediaPlayer::setHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
     if (info && info->result) {
         info->result->setCompleted();
@@ -680,10 +1128,28 @@ void ExternalMediaPlayer::executeProvideState(
     ACSDK_DEBUG(LX("executeProvideState").d("sendToken", sendToken).d("stateRequestToken", stateRequestToken));
     std::string state;
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates;
+    if (m_adapters.empty()) { // use handlers when there are no adapters
+        for (auto adapterHandler : m_adapterHandlers) {
+            auto handlerAdapterStates = adapterHandler->getAdapterStates();
+            adapterStates.insert(adapterStates.end(), handlerAdapterStates.begin(), handlerAdapterStates.end());
+        }
+    }
+#endif
+
     if (stateProviderName == SESSION_STATE) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        state = provideSessionState(adapterStates);
+#else
         state = provideSessionState();
+#endif
     } else if (stateProviderName == PLAYBACK_STATE) {
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        state = providePlaybackState(adapterStates);
+#else
         state = providePlaybackState();
+#endif
     } else {
         ACSDK_ERROR(LX("executeProvideState").d("reason", "unknownStateProviderName"));
         return;
@@ -701,12 +1167,19 @@ void ExternalMediaPlayer::executeProvideState(
     }
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+std::string ExternalMediaPlayer::provideSessionState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates) {
+#else
 std::string ExternalMediaPlayer::provideSessionState() {
+#endif
     rapidjson::Document state(rapidjson::kObjectType);
     rapidjson::Document::AllocatorType& stateAlloc = state.GetAllocator();
 
     state.AddMember(rapidjson::StringRef(PLAYER_IN_FOCUS), m_playerInFocus, stateAlloc);
-
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    state.AddMember(rapidjson::StringRef(SPI_VERSION), rapidjson::StringRef(SPI_VERSION_DEFAULT), stateAlloc);
+    state.AddMember(rapidjson::StringRef(AGENT), rapidjson::StringRef(AGENT_DEFAULT), stateAlloc);
+#endif
     rapidjson::Value players(rapidjson::kArrayType);
     for (const auto& adapter : m_adapters) {
         if (!adapter.second) {
@@ -719,6 +1192,16 @@ std::string ExternalMediaPlayer::provideSessionState() {
         notifyObservers(state.playerId, &update);
     }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    for (auto adapterState : adapterStates) {
+        if (adapterState.sessionState.playerId.empty()) {
+            continue;
+        }
+        rapidjson::Value playerJson = buildSessionState(adapterState.sessionState, stateAlloc);
+        players.PushBack(playerJson, stateAlloc);
+    }
+#endif
+
     state.AddMember(rapidjson::StringRef(PLAYERS), players, stateAlloc);
 
     rapidjson::StringBuffer buffer;
@@ -731,7 +1214,11 @@ std::string ExternalMediaPlayer::provideSessionState() {
     return buffer.GetString();
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+std::string ExternalMediaPlayer::providePlaybackState(std::vector<avsCommon::sdkInterfaces::externalMediaPlayer::AdapterState> adapterStates) {
+#else
 std::string ExternalMediaPlayer::providePlaybackState() {
+#endif
     rapidjson::Document state(rapidjson::kObjectType);
     rapidjson::Document::AllocatorType& stateAlloc = state.GetAllocator();
 
@@ -753,6 +1240,13 @@ std::string ExternalMediaPlayer::providePlaybackState() {
         notifyObservers(state.playerId, &update);
     }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    for (auto adapterState : adapterStates) {
+        rapidjson::Value playerJson = buildPlaybackState(adapterState.playbackState, stateAlloc);
+        players.PushBack(playerJson, stateAlloc);
+    }
+#endif
+
     state.AddMember(PLAYERS, players, stateAlloc);
 
     rapidjson::StringBuffer buffer;
diff --git a/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp b/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp
index 9976346..d4cdfde 100644
--- a/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp
+++ b/CapabilityAgents/ExternalMediaPlayer/test/ExternalMediaPlayerTest.cpp
@@ -96,6 +96,9 @@ static const std::string PLAYER_STATE = "IDLE";
 static const NamespaceAndName PLAY_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Play"};
 static const NamespaceAndName LOGIN_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Login"};
 static const NamespaceAndName LOGOUT_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "Logout"};
+#ifdef EXTERNALMEDIAPLAYER_1_1
+static const NamespaceAndName AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE{EXTERNALMEDIAPLAYER_NAMESPACE, "AuthorizeDiscoveredPlayers"};
+#endif
 
 // The @c Transport control directive signatures.
 static const NamespaceAndName RESUME_DIRECTIVE{PLAYBACKCONTROLLER_NAMESPACE, "Play"};
@@ -136,7 +139,15 @@ static const std::string IDLE_SESSION_STATE =
             "\"username\":\"\","
             "\"isGuest\":false,"
             "\"launched\":false,"
-           "\"active\":false}"
+            "\"active\":false"
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"spiVersion\":\"\","
+            "\"playerCookie\":\"\","
+            "\"skillToken\":\"\","
+            "\"playbackSessionId\":\"\""
+#endif
+        "}"
     "]}";
 
 static const std::string IDLE_PLAYBACK_STATE =
@@ -260,7 +271,12 @@ public:
             bool forceLogin,
             std::chrono::milliseconds tokenRefreshInterval));
     MOCK_METHOD0(handleLogout, void());
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    MOCK_METHOD7(handlePlay, void(std::string& playContextToken, int64_t index, std::chrono::milliseconds offset,
+        std::string& skillToken, std::string& playbackSessionId, std::string& navigation, bool preload));
+#else
     MOCK_METHOD3(handlePlay, void(std::string& playContextToken, int64_t index, std::chrono::milliseconds offset));
+#endif
     MOCK_METHOD1(handlePlayControl, void(RequestType requestType));
     MOCK_METHOD1(handleSeek, void(std::chrono::milliseconds offset));
     MOCK_METHOD1(handleAdjustSeek, void(std::chrono::milliseconds deltaOffset));
@@ -320,6 +336,53 @@ std::shared_ptr<MockExternalMediaPlayerObserver> MockExternalMediaPlayerObserver
 MockExternalMediaPlayerObserver::MockExternalMediaPlayerObserver() {
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/**
+ * Method to create AuthorizeDiscoveredPlayers payload.
+ *
+ * @return A string representation of the payload.
+ */
+static std::string createAuthorizeDiscoveredPlayersPayload() {
+    // clang-format off
+    // {
+    //     "directive": {
+    //         "header": {
+    //             "namespace": "ExternalMediaPlayer",
+    //             "name": "AuthorizeDiscoveredPlayers"
+    //         },
+    //         "payload": {
+    //             "players" : [
+    //                 {
+    //                     "localPlayerId": "{{STRING}}",
+    //                     "authorized": {{BOOLEAN}},
+    //                     "metadata": {
+    //                         "playerId": "{{STRING}}",
+    //                         "skillToken": "{{STRING}}"
+    //                     }
+    //                 }
+    //             ]
+    //         }
+    //     }
+    // }
+    const std::string AUTHORIZEDISCOVEREDPLAYERS_PAYLOAD_TEST =
+        "{"
+            "\"players\" : ["
+                "{"
+                    "\"localPlayerId\": \"Spotify:ESDK\","
+                    "\"authorized\": true,"
+                    "\"metadata\": {"
+                        "\"playerId\": \"Spotify\","
+                        "\"skillToken\": \"YYY\""
+                    "}"
+                "}"
+            "]"
+        "}";
+    // clang-format on
+
+    return AUTHORIZEDISCOVEREDPLAYERS_PAYLOAD_TEST;
+}
+#endif
+
 /**
  * Method to create payload with parse error.
  *
@@ -333,7 +396,15 @@ static std::string createPlayPayloadWithParseError(
     const std::string& playContext,
     int index,
     int64_t offsetInMilliseconds,
-    const std::string& playerId) {
+    const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
@@ -341,6 +412,13 @@ static std::string createPlayPayloadWithParseError(
             "\"offsetInMilliseconds\":" + std::to_string(offsetInMilliseconds) + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\","
+#ifdef EXTERNALMEDIAPLAYER_1_1
+//             ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
     // clang-format on
 
@@ -377,7 +455,15 @@ static std::string createPlayPayload(
     const std::string& playContext,
     int index,
     int64_t offsetInMilliseconds,
-    const std::string& playerId) {
+    const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
@@ -385,6 +471,13 @@ static std::string createPlayPayload(
             "\"offsetInMilliseconds\":\"" + std::to_string(offsetInMilliseconds) + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
     // clang-format on
 
@@ -399,13 +492,28 @@ static std::string createPlayPayload(
  * @param playerId The business name of the player.
  * @return A string representation of the payload.
  */
-static std::string createPlayPayloadNoContext(int index, int64_t offsetInMilliseconds, const std::string& playerId) {
+static std::string createPlayPayloadNoContext(int index, int64_t offsetInMilliseconds, const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"offsetInMilliseconds\":\"" + std::to_string(offsetInMilliseconds) + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
     // clang-format on
 
@@ -423,13 +531,28 @@ static std::string createPlayPayloadNoContext(int index, int64_t offsetInMillise
 static std::string createPlayPayloadNoPlayerId(
     const std::string& playContext,
     int index,
-    int64_t offsetInMilliseconds) {
+    int64_t offsetInMilliseconds
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"playbackContextToken\":\"" + playContext + "\","
             "\"offsetInMilliseconds\":\"" + std::to_string(offsetInMilliseconds) + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
 
     // clang-format on
@@ -448,13 +571,28 @@ static std::string createPlayPayloadNoPlayerId(
 static std::string createPlayPayloadNoIndex(
     const std::string& playContext,
     int64_t offsetInMilliseconds,
-    const std::string& playerId) {
+    const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+    ) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"playbackContextToken\":\"" + playContext + "\","
             "\"offsetInMilliseconds\":" + std::to_string(offsetInMilliseconds) + ","
             "\"playerId\":\"" + playerId + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
 
     // clang-format on
@@ -470,13 +608,28 @@ static std::string createPlayPayloadNoIndex(
  * @param playerId The business name of the player.
  * @return A string representation of the payload.
  */
-static std::string createPlayPayloadNoOffset(const std::string& playContext, int index, const std::string& playerId) {
+static std::string createPlayPayloadNoOffset(const std::string& playContext, int index, const std::string& playerId
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ,
+    const std::string& skillToken,
+    const std::string& playbackSessionId,
+    const std::string& navigation, // DEFAULT, NONE, FOREGROUND
+    bool preload
+#endif
+) {
     // clang-format off
     const std::string PLAY_PAYLOAD_TEST =
         "{"
             "\"playbackContextToken\":\"" + playContext + "\","
             "\"playerId\":\"" + playerId + "\","
             "\"index\":\"" + std::to_string(index) + "\""
+#ifdef EXTERNALMEDIAPLAYER_1_1
+            ","
+            "\"skillToken\":\"" + skillToken + "\","
+            "\"playbackSessionId\":\"" + playbackSessionId + "\","
+            "\"navigation\":\"" + navigation + "\"," // DEFAULT, NONE, FOREGROUND
+            "\"preload\":" + (preload ? "true" : "false") + ""
+#endif
         "}";
 
     // clang-format on
@@ -813,6 +966,9 @@ TEST_F(ExternalMediaPlayerTest, testGetConfiguration) {
 
     // TODO: ARC-227 Verify default values
     ASSERT_EQ(configuration[PLAY_DIRECTIVE], audioNonBlockingPolicy);
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    ASSERT_EQ(configuration[AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE], audioNonBlockingPolicy);
+#endif
     ASSERT_EQ(configuration[LOGIN_DIRECTIVE], neitherNonBlockingPolicy);
     ASSERT_EQ(configuration[LOGOUT_DIRECTIVE], neitherNonBlockingPolicy);
     ASSERT_EQ(configuration[RESUME_DIRECTIVE], audioNonBlockingPolicy);
@@ -886,7 +1042,11 @@ TEST_F(ExternalMediaPlayerTest, testPlayParserError) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadWithParseError("XXX", 0, 0, "Spotify", "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadWithParseError("XXX", 0, 0, "Spotify"), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -903,7 +1063,11 @@ TEST_F(ExternalMediaPlayerTest, testPlayNoAdapter) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive =
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        AVSDirective::create("", avsMessageHeader, createPlayPayload("XXX", 0, 0, "Spotify", "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         AVSDirective::create("", avsMessageHeader, createPlayPayload("XXX", 0, 0, "Spotify"), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -920,7 +1084,11 @@ TEST_F(ExternalMediaPlayerTest, testPlayNoPlayContext) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadNoContext(0, 0, MSP_NAME1, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadNoContext(0, 0, MSP_NAME1), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -937,7 +1105,11 @@ TEST_F(ExternalMediaPlayerTest, testPlayNoPlayerId) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive =
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        AVSDirective::create("", avsMessageHeader, createPlayPayloadNoPlayerId("XXX", 0, 0, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         AVSDirective::create("", avsMessageHeader, createPlayPayloadNoPlayerId("XXX", 0, 0), m_attachmentManager, "");
+#endif
 
     EXPECT_CALL(*(m_mockExceptionSender.get()), sendExceptionEncountered(_, _, _));
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setFailed(_));
@@ -954,9 +1126,17 @@ TEST_F(ExternalMediaPlayerTest, testPlayNoOffset) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadNoOffset("XXX", 0, MSP_NAME1, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadNoOffset("XXX", 0, MSP_NAME1), m_attachmentManager, "");
+#endif
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _, _, _, _, _));
+#else
     EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _));
+#endif
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setCompleted());
 
     m_externalMediaPlayer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
@@ -971,15 +1151,39 @@ TEST_F(ExternalMediaPlayerTest, testPlayNoIndex) {
         PLAY_DIRECTIVE.nameSpace, PLAY_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
 
     std::shared_ptr<AVSDirective> directive = AVSDirective::create(
+#ifdef EXTERNALMEDIAPLAYER_1_1
+        "", avsMessageHeader, createPlayPayloadNoIndex("XXX", 0, MSP_NAME1, "YYY", "ZZZ", "DEFAULT", false), m_attachmentManager, "");
+#else
         "", avsMessageHeader, createPlayPayloadNoIndex("XXX", 0, MSP_NAME1), m_attachmentManager, "");
+#endif
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+    EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _, _, _, _, _));
+#else
     EXPECT_CALL(*(MockExternalMediaPlayerAdapter::m_currentActiveMediaPlayerAdapter), handlePlay(_, _, _));
+#endif
     EXPECT_CALL(*m_mockDirectiveHandlerResult, setCompleted());
 
     m_externalMediaPlayer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
     m_externalMediaPlayer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
 }
 
+#ifdef EXTERNALMEDIAPLAYER_1_1
+/**
+ * Test successful AuthorizeDiscoveredPlayers.
+ */
+TEST_F(ExternalMediaPlayerTest, testAuthorizeDiscoveredPlayers) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE.nameSpace, AUTHORIZEDISCOVEREDPLAYERS_DIRECTIVE.name, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, createAuthorizeDiscoveredPlayersPayload(), m_attachmentManager, "");
+
+    m_externalMediaPlayer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
+    m_externalMediaPlayer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+}
+#endif
+
 /**
  * Test successful logout.
  */
diff --git a/CapabilityAgents/Settings/include/Settings/Settings.h b/CapabilityAgents/Settings/include/Settings/Settings.h
index 0add1cf..7ef640a 100644
--- a/CapabilityAgents/Settings/include/Settings/Settings.h
+++ b/CapabilityAgents/Settings/include/Settings/Settings.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -100,6 +100,15 @@ public:
      */
     std::future<bool> changeSetting(const std::string& key, const std::string& value);
 
+    /**
+     * Function called by the application to get a Settings value.
+     *
+     * @param key The name of the setting which is queried.
+     * @param value The value of the setting.
+     * @return @c true if key is found else @c false.
+     */
+    bool getSetting(const std::string& key, std::string& value);
+
     /**
      * Function which sends the default settings to AVS if the settings do not already exist in the database.
      * If the settings already exist, the event is not sent.
diff --git a/CapabilityAgents/Settings/src/Settings.cpp b/CapabilityAgents/Settings/src/Settings.cpp
index 7e72637..cd2fa43 100644
--- a/CapabilityAgents/Settings/src/Settings.cpp
+++ b/CapabilityAgents/Settings/src/Settings.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -166,6 +166,15 @@ std::future<bool> Settings::changeSetting(const std::string& key, const std::str
     return m_executor.submit([this, key, value] { return executeChangeSetting(key, value); });
 }
 
+bool Settings::getSetting(const std::string& key, std::string& value) {
+    auto search = m_mapOfSettingsAttributes.find(key);
+    if (search != m_mapOfSettingsAttributes.end()) {
+        value = search->second.valueOfSetting;
+        return true;
+    }
+    return false;
+}
+
 bool Settings::executeChangeSetting(const std::string& key, const std::string& value) {
     if (!m_settingsStorage->modify(key, value)) {
         ACSDK_ERROR(LX("executeSettingChangedFailed").d("reason", "databaseUpdateFailed"));
diff --git a/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h b/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h
index e4f6cc4..ed5cc6b 100644
--- a/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h
+++ b/CapabilityAgents/SpeechSynthesizer/include/SpeechSynthesizer/SpeechSynthesizer.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -171,6 +171,12 @@ private:
 
         /// A flag to indicate if setFailed() has been sent to the @c DirectiveSequencer.
         bool isSetFailedCalled;
+
+        /// A flag to indicate if playback has been initiated.
+        bool isPlaybackInitiated;
+
+        /// A flag to indicate that cancel has been called.
+        bool isDelayCancel;
     };
 
     /**
@@ -251,6 +257,12 @@ private:
      */
     void executeCancel(std::shared_ptr<DirectiveInfo> info);
 
+    /**
+     * Cancel execution of a SpeechSynthesizer. Speak directive (on the @c m_executor thread).
+     * @param speakInfo The speakInfoDirective to cancel.
+     */
+    void executeCancel(std::shared_ptr<SpeakDirectiveInfo> speakInfo);
+
     /**
      * Execute a change of state (on the @c m_executor thread). If the @c m_desiredState is @c PLAYING, playing the
      * audio of the current directive is started. If the @c m_desiredState is @c FINISHED this method triggers
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index d0883af..48cdad2 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -185,12 +185,17 @@ void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
 }
 
 void SpeechSynthesizer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
-    ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
-    m_executor.submit([this, info]() { executeCancel(info); });
+    if (info && info->directive) {
+        ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
+        m_executor.submit([this, info]() { executeCancel(info); });
+    } else {
+        ACSDK_WARN(LX("cancelDirective").d("reason", "infoNotAvailable"));
+    }
 }
 
 void SpeechSynthesizer::onFocusChanged(FocusState newFocus) {
     ACSDK_DEBUG(LX("onFocusChanged").d("newFocus", newFocus));
+
     std::unique_lock<std::mutex> lock(m_mutex);
     m_currentFocus = newFocus;
     setDesiredStateLocked(newFocus);
@@ -225,6 +230,13 @@ void SpeechSynthesizer::onFocusChanged(FocusState newFocus) {
                 m_currentInfo, avsCommon::avs::ExceptionErrorType::INTERNAL_ERROR, "stateChangeTimeout");
         }
     }
+
+    m_executor.submit([this, messageId]() {
+        auto speakInfo = getSpeakDirectiveInfo(messageId);
+        if (speakInfo && speakInfo->isDelayCancel && speakInfo->directive) {
+            executeCancel(speakInfo);
+        }
+    });
 }
 
 void SpeechSynthesizer::provideState(
@@ -312,7 +324,9 @@ SpeechSynthesizer::SpeakDirectiveInfo::SpeakDirectiveInfo(std::shared_ptr<Direct
         sendPlaybackStartedMessage{false},
         sendPlaybackFinishedMessage{false},
         sendCompletedMessage{false},
-        isSetFailedCalled{false} {
+        isSetFailedCalled{false},
+        isPlaybackInitiated{false},
+        isDelayCancel{false} {
 }
 
 void SpeechSynthesizer::SpeakDirectiveInfo::clear() {
@@ -321,6 +335,8 @@ void SpeechSynthesizer::SpeakDirectiveInfo::clear() {
     sendPlaybackFinishedMessage = false;
     sendCompletedMessage = false;
     isSetFailedCalled = false;
+    isPlaybackInitiated = false;
+    isDelayCancel = false;
 }
 
 SpeechSynthesizer::SpeechSynthesizer(
@@ -460,7 +476,7 @@ void SpeechSynthesizer::executePreHandleAfterValidation(std::shared_ptr<SpeakDir
     auto contentIdPosition = urlValue.find(CID_PREFIX);
     if (contentIdPosition != 0) {
         const std::string message("expectedCIDUrlPrefixNotFound");
-        ACSDK_ERROR(LX("executePreHandleFailed").d("reason", message).d("url", urlValue));
+        ACSDK_ERROR(LX("executePreHandleFailed").d("reason", message).sensitive("url", urlValue));
         sendExceptionEncounteredAndReportFailed(
             speakInfo, avsCommon::avs::ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED, message);
         return;
@@ -515,10 +531,15 @@ void SpeechSynthesizer::executeHandle(std::shared_ptr<DirectiveInfo> info) {
 void SpeechSynthesizer::executeCancel(std::shared_ptr<DirectiveInfo> info) {
     ACSDK_DEBUG(LX("executeCancel").d("messageId", info->directive->getMessageId()));
     auto speakInfo = validateInfo("executeCancel", info);
+    executeCancel(speakInfo);
+}
+
+void SpeechSynthesizer::executeCancel(std::shared_ptr<SpeakDirectiveInfo> speakInfo) {
     if (!speakInfo) {
         ACSDK_ERROR(LX("executeCancelFailed").d("reason", "invalidDirectiveInfo"));
         return;
     }
+    ACSDK_DEBUG(LX("executeCancel").d("messageId", speakInfo->directive->getMessageId()));
     if (speakInfo != m_currentInfo) {
         speakInfo->clear();
         removeSpeakDirectiveInfo(speakInfo->directive->getMessageId());
@@ -534,17 +555,20 @@ void SpeechSynthesizer::executeCancel(std::shared_ptr<DirectiveInfo> info) {
         removeDirective(speakInfo->directive->getMessageId());
         return;
     }
-    std::unique_lock<std::mutex> lock(m_mutex);
-    if (SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED != m_desiredState) {
-        m_desiredState = SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED;
-        if (SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING == m_currentState ||
-            SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS == m_currentState) {
+
+    if (m_currentInfo) {
+        if (m_currentInfo->isPlaybackInitiated) {
+            std::unique_lock<std::mutex> lock(m_mutex);
+            m_desiredState = SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED;
             lock.unlock();
-            if (m_currentInfo) {
-                m_currentInfo->sendPlaybackFinishedMessage = false;
-                m_currentInfo->sendCompletedMessage = false;
-            }
+
+            m_currentInfo->sendPlaybackStartedMessage = false;
+            m_currentInfo->sendCompletedMessage = false;
             stopPlaying();
+
+        } else {
+            // Playback has not been initiated yet. Setting
+            m_currentInfo->isDelayCancel = true;
         }
     }
 }
@@ -562,8 +586,9 @@ void SpeechSynthesizer::executeStateChange() {
                 m_currentInfo->sendPlaybackStartedMessage = true;
                 m_currentInfo->sendPlaybackFinishedMessage = true;
                 m_currentInfo->sendCompletedMessage = true;
+                m_currentInfo->isPlaybackInitiated = true;
+                startPlaying();
             }
-            startPlaying();
             break;
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED:
             // This happens when focus state is changed to BACKGROUND or NONE, requiring the @c SpeechSynthesizer to
@@ -575,8 +600,11 @@ void SpeechSynthesizer::executeStateChange() {
                     m_currentInfo->result->setFailed("Stopped due to SpeechSynthesizer going into FINISHED state.");
                     m_currentInfo->isSetFailedCalled = true;
                 }
+
+                if (m_currentInfo->isPlaybackInitiated) {
+                    stopPlaying();
+                }
             }
-            stopPlaying();
             break;
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS:
         case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::LOSING_FOCUS:
@@ -662,12 +690,16 @@ void SpeechSynthesizer::executePlaybackFinished() {
         setCurrentStateLocked(SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED);
     }
     m_waitOnStateChange.notify_one();
-    if (m_currentInfo->sendPlaybackFinishedMessage) {
+    if (m_currentInfo && m_currentInfo->sendPlaybackFinishedMessage) {
         auto payload = buildPayload(m_currentInfo->token);
         if (payload.empty()) {
+            std::string messageId;
+            if (m_currentInfo && m_currentInfo->directive) {
+                messageId = m_currentInfo->directive->getMessageId();
+            }
             ACSDK_ERROR(LX("executePlaybackFinishedFailed")
                             .d("reason", "buildPayloadFailed")
-                            .d("messageId", m_currentInfo->directive->getMessageId()));
+                            .d("messageId", messageId));
         } else {
             auto msgIdAndJsonEvent = buildJsonEventString(SPEECH_FINISHED_EVENT_NAME, "", payload);
 
@@ -675,15 +707,17 @@ void SpeechSynthesizer::executePlaybackFinished() {
             m_messageSender->sendMessage(request);
         }
     }
-    if (m_currentInfo->sendCompletedMessage) {
+    if (m_currentInfo && m_currentInfo->sendCompletedMessage) {
         setHandlingCompleted();
     }
     resetCurrentInfo();
     {
-        std::lock_guard<std::mutex> lock_guard(m_speakInfoQueueMutex);
-        m_speakInfoQueue.pop_front();
         if (!m_speakInfoQueue.empty()) {
-            executeHandleAfterValidation(m_speakInfoQueue.front());
+            std::lock_guard<std::mutex> lock_guard(m_speakInfoQueueMutex);
+            m_speakInfoQueue.pop_front();
+            if (!m_speakInfoQueue.empty()) {
+                executeHandleAfterValidation(m_speakInfoQueue.front());
+            }
         }
     }
     resetMediaSourceId();
@@ -760,7 +794,11 @@ std::string SpeechSynthesizer::buildPayload(std::string& token) {
 
 void SpeechSynthesizer::startPlaying() {
     ACSDK_DEBUG9(LX("startPlaying"));
-    m_mediaSourceId = m_speechPlayer->setSource(std::move(m_currentInfo->attachmentReader));
+    if (m_currentInfo && m_currentInfo->attachmentReader) {
+        m_mediaSourceId = m_speechPlayer->setSource(std::move(m_currentInfo->attachmentReader));
+    } else {
+        m_mediaSourceId = MediaPlayerInterface::ERROR;
+    }
     if (MediaPlayerInterface::ERROR == m_mediaSourceId) {
         ACSDK_ERROR(LX("startPlayingFailed").d("reason", "setSourceFailed"));
         executePlaybackError(ErrorType::MEDIA_ERROR_INTERNAL_DEVICE_ERROR, "playFailed");
@@ -818,9 +856,14 @@ void SpeechSynthesizer::setDesiredStateLocked(FocusState newFocus) {
 void SpeechSynthesizer::resetCurrentInfo(std::shared_ptr<SpeakDirectiveInfo> speakInfo) {
     if (m_currentInfo != speakInfo) {
         if (m_currentInfo) {
-            removeSpeakDirectiveInfo(m_currentInfo->directive->getMessageId());
-            removeDirective(m_currentInfo->directive->getMessageId());
-            m_currentInfo->clear();
+            auto info = m_currentInfo;
+            if (info) {
+                if (info->directive) {
+                    removeSpeakDirectiveInfo(info->directive->getMessageId());
+                    removeDirective(info->directive->getMessageId());
+                }
+                info->clear();
+            }
         }
         m_currentInfo = speakInfo;
     }
diff --git a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
index 117d6fa..755164c 100644
--- a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -757,6 +757,143 @@ TEST_F(SpeechSynthesizerTest, testNotCallStopTwice) {
     ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
 }
 
+TEST_F(SpeechSynthesizerTest, testCallingCancelBeforeOnFocusChanged) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST_2);
+    std::shared_ptr<AVSDirective> directive2 =
+        AVSDirective::create("", avsMessageHeader2, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST_2);
+
+    EXPECT_CALL(*(m_mockFocusManager.get()), acquireChannel(CHANNEL_NAME, _, NAMESPACE_SPEECH_SYNTHESIZER))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+    EXPECT_CALL(*(m_mockDirHandlerResult.get()), setFailed(_))
+        .Times(1)
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetFailed));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, FINISHED_STATE_TEST, StateRefreshPolicy::NEVER, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(
+        *(m_mockSpeechPlayer.get()),
+        attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr))
+        .Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), play(_)).Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+
+    m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirHandlerResult));
+    m_speechSynthesizer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeAcquireChannelPromise = std::promise<void>();
+    m_wakeAcquireChannelFuture = m_wakeAcquireChannelPromise.get_future();
+
+    m_speechSynthesizer->CapabilityAgent::cancelDirective(MESSAGE_ID_TEST);
+    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetFailedFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetFailedPromise = std::promise<void>();
+    m_wakeSetFailedFuture = m_wakeSetFailedPromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    // send second speak directive and make sure it working
+    m_speechSynthesizer->handleDirectiveImmediately(directive2);
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+}
+
+TEST_F(SpeechSynthesizerTest, testCallingCancelBeforeOnExecuteStateChanged) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST_2);
+    std::shared_ptr<AVSDirective> directive2 =
+        AVSDirective::create("", avsMessageHeader2, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST_2);
+
+    EXPECT_CALL(*(m_mockFocusManager.get()), acquireChannel(CHANNEL_NAME, _, NAMESPACE_SPEECH_SYNTHESIZER))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+    EXPECT_CALL(*(m_mockDirHandlerResult.get()), setFailed(_))
+        .Times(1)
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetFailed));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, FINISHED_STATE_TEST, StateRefreshPolicy::NEVER, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(
+        *(m_mockSpeechPlayer.get()),
+        attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr))
+        .Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), play(_)).Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+
+    m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirHandlerResult));
+    m_speechSynthesizer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeAcquireChannelPromise = std::promise<void>();
+    m_wakeAcquireChannelFuture = m_wakeAcquireChannelPromise.get_future();
+
+    m_speechSynthesizer->CapabilityAgent::cancelDirective(MESSAGE_ID_TEST);
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetFailedFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetFailedPromise = std::promise<void>();
+    m_wakeSetFailedFuture = m_wakeSetFailedPromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    // send second speak directive and make sure it working
+    m_speechSynthesizer->handleDirectiveImmediately(directive2);
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+}
+
 /**
  * Testing SpeechSynthesizer will continue to function properly if stop() in @c MediaPlayer returned with an error.
  * Call preHandle with a valid SPEAK directive. Then call handleDirective. Expected result is that @c acquireChannel
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 7332ca1..e29157d 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -86,13 +86,13 @@ static const std::string AUDIO_ITEM_ID_TAG{"audioItemId"};
 static const size_t MAXIMUM_QUEUE_SIZE{100};
 
 /// Default timeout for clearing the RenderTemplate display card when SpeechSynthesizer is in FINISHED state.
-static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{2000};
+static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{8000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in FINISHED state.
 static const std::chrono::milliseconds DEFAULT_AUDIO_FINISHED_TIMEOUT_MS{2000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in STOPPED/PAUSED state.
-static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{60000};
+static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{1800000};
 
 /**
  * Creates the TemplateRuntime capability configuration.
@@ -155,11 +155,16 @@ bool TemplateRuntime::initialize() {
 
 void TemplateRuntime::handleDirectiveImmediately(std::shared_ptr<AVSDirective> directive) {
     ACSDK_DEBUG5(LX("handleDirectiveImmediately"));
-    preHandleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
+    handleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
 }
 
 void TemplateRuntime::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
     ACSDK_DEBUG5(LX("preHandleDirective"));
+    // do nothing.
+}
+
+void TemplateRuntime::handleDirective(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX("handleDirective"));
     if (!info || !info->directive) {
         ACSDK_ERROR(LX("preHandleDirectiveFailed").d("reason", "nullDirectiveInfo"));
         return;
@@ -173,11 +178,6 @@ void TemplateRuntime::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
     }
 }
 
-void TemplateRuntime::handleDirective(std::shared_ptr<DirectiveInfo> info) {
-    ACSDK_DEBUG5(LX("handleDirective"));
-    // Do nothing here as directives are handled in the preHandle stage.
-}
-
 void TemplateRuntime::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
     removeDirective(info);
 }
diff --git a/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp b/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
index fb3bad7..62a1772 100644
--- a/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
+++ b/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
@@ -338,6 +338,7 @@ TEST_F(TemplateRuntimeTest, testUnknownDirective) {
         .WillOnce(InvokeWithoutArgs(this, &TemplateRuntimeTest::wakeOnSetCompleted));
 
     m_templateRuntime->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
+    m_templateRuntime->CapabilityAgent::handleDirective(MESSAGE_ID);
     m_wakeSetCompletedFuture.wait_for(TIMEOUT);
 }
 
@@ -481,6 +482,7 @@ TEST_F(TemplateRuntimeTest, testRenderPlayerInfoDirectiveWithoutAudioItemId) {
         .WillOnce(InvokeWithoutArgs(this, &TemplateRuntimeTest::wakeOnSetCompleted));
 
     m_templateRuntime->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
+    m_templateRuntime->CapabilityAgent::handleDirective(MESSAGE_ID);
     m_wakeSetCompletedFuture.wait_for(TIMEOUT);
 }
 
@@ -501,6 +503,7 @@ TEST_F(TemplateRuntimeTest, testMalformedRenderPlayerInfoDirective) {
         .WillOnce(InvokeWithoutArgs(this, &TemplateRuntimeTest::wakeOnSetCompleted));
 
     m_templateRuntime->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirectiveHandlerResult));
+    m_templateRuntime->CapabilityAgent::handleDirective(MESSAGE_ID);
     m_wakeSetCompletedFuture.wait_for(TIMEOUT);
 }
 
diff --git a/MediaPlayer/GStreamerMediaPlayer/test/MediaPlayerTest.cpp b/MediaPlayer/GStreamerMediaPlayer/test/MediaPlayerTest.cpp
index c84416a..db9f231 100644
--- a/MediaPlayer/GStreamerMediaPlayer/test/MediaPlayerTest.cpp
+++ b/MediaPlayer/GStreamerMediaPlayer/test/MediaPlayerTest.cpp
@@ -101,45 +101,52 @@ static std::unordered_map<std::string, std::string> urlsToContent;
 /// A mock content fetcher
 class MockContentFetcher : public avsCommon::sdkInterfaces::HTTPContentFetcherInterface {
 public:
-    MockContentFetcher(const std::string& url) : m_url{url} {
+    MockContentFetcher(const std::string& url) : m_url{url}, m_state{HTTPContentFetcherInterface::State::INITIALIZED} {
+    }
+
+    std::string getUrl() const override {
+        return m_url;
+    }
+
+    HTTPContentFetcherInterface::Header getHeader(std::atomic<bool>* shouldShutdown) override {
+        HTTPContentFetcherInterface::Header header;
+        auto urlAndContentType = urlsToContentTypes.find(m_url);
+        if (urlAndContentType == urlsToContentTypes.end()) {
+            header.successful = false;
+        } else {
+            header.successful = true;
+            header.responseCode = avsCommon::utils::http::HTTPResponseCode::SUCCESS_OK;
+            header.contentType = urlAndContentType->second;
+            m_state = HTTPContentFetcherInterface::State::HEADER_DONE;
+        }
+        return header;
+    }
+
+    HTTPContentFetcherInterface::State getState() override {
+        return m_state;
+    }
+
+    bool getBody(std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer) override {
+        auto urlAndContent = urlsToContent.find(m_url);
+        if (urlAndContent == urlsToContent.end()) {
+            return false;
+        }
+        auto attachment = writeStringIntoAttachment(urlAndContent->second, std::move(writer));
+        if (!attachment) {
+            return false;
+        }
+        m_state = HTTPContentFetcherInterface::State::BODY_DONE;
+        return true;
+    }
+
+    void shutdown() override {
     }
 
     std::unique_ptr<avsCommon::utils::HTTPContent> getContent(
         FetchOptions fetchOption,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer,
+        std::unique_ptr<avsCommon::avs::attachment::AttachmentWriter> writer,
         const std::vector<std::string>& customHeaders = std::vector<std::string>()) override {
-        if (fetchOption == FetchOptions::CONTENT_TYPE) {
-            auto urlAndContentType = urlsToContentTypes.find(m_url);
-            if (urlAndContentType == urlsToContentTypes.end()) {
-                return nullptr;
-            } else {
-                std::promise<long> statusPromise;
-                auto statusFuture = statusPromise.get_future();
-                statusPromise.set_value(200);
-                std::promise<std::string> contentTypePromise;
-                auto contentTypeFuture = contentTypePromise.get_future();
-                contentTypePromise.set_value(urlAndContentType->second);
-                return avsCommon::utils::memory::make_unique<avsCommon::utils::HTTPContent>(
-                    std::move(statusFuture), std::move(contentTypeFuture), nullptr);
-            }
-        } else {
-            auto urlAndContent = urlsToContent.find(m_url);
-            if (urlAndContent == urlsToContent.end()) {
-                return nullptr;
-            }
-            std::promise<long> statusPromise;
-            auto statusFuture = statusPromise.get_future();
-            statusPromise.set_value(200);
-            std::promise<std::string> contentTypePromise;
-            auto contentTypeFuture = contentTypePromise.get_future();
-            contentTypePromise.set_value("");
-            auto attachment = writeStringIntoAttachment(urlAndContent->second, writer);
-            if (!attachment) {
-                return nullptr;
-            }
-            return avsCommon::utils::memory::make_unique<avsCommon::utils::HTTPContent>(
-                std::move(statusFuture), std::move(contentTypeFuture), attachment);
-        }
+        return nullptr;
     }
 
 private:
@@ -162,6 +169,8 @@ private:
     };
 
     std::string m_url;
+
+    HTTPContentFetcherInterface::State m_state;
 };
 
 /// A mock factory that creates mock content fetchers
diff --git a/PlaylistParser/include/PlaylistParser/PlaylistUtils.h b/PlaylistParser/include/PlaylistParser/PlaylistUtils.h
index c0c0b64..984ad31 100644
--- a/PlaylistParser/include/PlaylistParser/PlaylistUtils.h
+++ b/PlaylistParser/include/PlaylistParser/PlaylistUtils.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -25,9 +25,6 @@
 namespace alexaClientSDK {
 namespace playlistParser {
 
-/// Timeout for future ready.
-static const std::chrono::milliseconds WAIT_FOR_FUTURE_READY_TIMEOUT(100);
-
 /**
  * Parses an PLS playlist and returns the "children" URLs in the order they appeared in the playlist.
  *
@@ -47,13 +44,17 @@ void removeCarriageReturnFromLine(std::string* line);
 /**
  * Retrieves playlist content and stores it into a string.
  *
- * @param httpContent Object used to retrieve url content.
+ * @param contentFetcher Object used to retrieve url content.
  * @param [out] content The playlist content.
+ * @param shouldShutDown A pointer to allow for the caller to cancel the content retrieval asynchronously
  * @return @c true if no error occured or @c false otherwise.
  * @note This function should be used to retrieve content specifically from playlist URLs. Attempting to use this
  * on a media URL could be blocking forever as the URL might point to a live stream.
  */
-bool extractPlaylistContent(std::unique_ptr<avsCommon::utils::HTTPContent> httpContent, std::string* content);
+bool readFromContentFetcher(
+    std::unique_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher,
+    std::string* content,
+    std::atomic<bool>* shouldShutDown);
 
 /**
  * Determines whether the provided url is an absolute url as opposed to a relative url. This is done by simply
diff --git a/PlaylistParser/include/PlaylistParser/UrlContentToAttachmentConverter.h b/PlaylistParser/include/PlaylistParser/UrlContentToAttachmentConverter.h
index fa7ecdb..cf244a2 100644
--- a/PlaylistParser/include/PlaylistParser/UrlContentToAttachmentConverter.h
+++ b/PlaylistParser/include/PlaylistParser/UrlContentToAttachmentConverter.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -133,12 +133,14 @@ private:
      * @param url The URL to download.
      * @param headers HTTP headers to pass to server.
      * @param encryptionInfo The Encryption info for the URL to download.
+     * @param contentFetcher The content fetcher to use to retrieve content. Can be a null pointer.
      * @return @c true if the content was successfully streamed and written or @c false otherwise.
      */
     bool writeDecryptedUrlContentIntoStream(
         std::string url,
         std::vector<std::string> headers,
-        avsCommon::utils::playlistParser::EncryptionInfo encryptionInfo);
+        avsCommon::utils::playlistParser::EncryptionInfo encryptionInfo,
+        std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher);
 
     /**
      * Downloads the content from the url and writes to the stream.
@@ -146,12 +148,14 @@ private:
      * @param url The URL to download.
      * @param headers HTTP headers to pass to server.
      * @param streamWriter The attachment writer to write downloaded content.
+     * @param contentFetcher The content fetcher to use to retrieve content. Can be a null pointer.
      * @return @c true if the content was successfully downloaded or @c false otherwise.
      */
     bool download(
         const std::string& url,
         const std::vector<std::string>& headers,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> streamWriter);
+        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> streamWriter,
+        std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher);
 
     /**
      * Downloads the content from the url to unsigned char vector.
@@ -159,9 +163,14 @@ private:
      * @param url The URL to download.
      * @param headers HTTP headers to pass to server.
      * @param[out] content Sets the content of the pointer if download is successful.
+     * @param contentFetcher The content fetcher to use to retrieve content. Can be a null pointer.
      * @return @c true if the content was successfully downloaded or @c false otherwise.
      */
-    bool download(const std::string& url, const std::vector<std::string>& headers, ByteVector* content);
+    bool download(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        ByteVector* content,
+        std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher);
 
     /**
      * Reads content from the reader to unsigned char vector.
diff --git a/PlaylistParser/src/IterativePlaylistParser.cpp b/PlaylistParser/src/IterativePlaylistParser.cpp
index 6006a9e..140e0b1 100644
--- a/PlaylistParser/src/IterativePlaylistParser.cpp
+++ b/PlaylistParser/src/IterativePlaylistParser.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/PlaylistParser/PlaylistParserObserverInterface.h>
+#include <AVSCommon/Utils/String/StringUtils.h>
 
 #include "PlaylistParser/IterativePlaylistParser.h"
 #include "PlaylistParser/PlaylistUtils.h"
@@ -25,7 +26,9 @@
 namespace alexaClientSDK {
 namespace playlistParser {
 
+using namespace avsCommon::sdkInterfaces;
 using namespace avsCommon::utils::playlistParser;
+using namespace avsCommon::utils::string;
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("IterativePlaylistParser");
@@ -90,33 +93,29 @@ PlaylistEntry IterativePlaylistParser::next() {
             return PlaylistEntry::createErrorEntry(playlistURL);
         }
 
-        auto httpContent = contentFetcher->getContent(
-            avsCommon::sdkInterfaces::HTTPContentFetcherInterface::FetchOptions::CONTENT_TYPE);
-        if (!httpContent) {
-            ACSDK_ERROR(LX("nextFailed").d("reason", "nullHTTPContentReceived").sensitive("url", playlistURL));
-            return PlaylistEntry::createErrorEntry(playlistURL);
+        contentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
+        auto header = contentFetcher->getHeader(&m_abort);
+        if (m_abort) {
+            ACSDK_DEBUG9(LX("nextFailed").d("info", "aborting"));
+            break;
         }
-        do {
-            if (m_abort) {
-                ACSDK_DEBUG9(LX("nextFailed").d("info", "aborting"));
-                break;
-            }
-        } while (!httpContent->isReady(WAIT_FOR_FUTURE_READY_TIMEOUT));
-        if (!httpContent->isStatusCodeSuccess()) {
+
+        if (!header.successful || !isStatusCodeSuccess(header.responseCode)) {
             ACSDK_ERROR(LX("nextFailed")
                             .d("reason", "badHTTPContentReceived")
-                            .d("statusCode", httpContent->getStatusCode())
+                            .d("statusCode", header.responseCode)
                             .sensitive("url", playlistURL));
             return PlaylistEntry::createErrorEntry(playlistURL);
         }
 
-        std::string contentType = httpContent->getContentType();
-        ACSDK_DEBUG9(LX("contentReceived").d("contentType", contentType).sensitive("url", playlistURL));
-        std::transform(contentType.begin(), contentType.end(), contentType.begin(), ::tolower);
+        ACSDK_DEBUG9(LX("contentReceived").d("contentType", header.contentType).sensitive("url", playlistURL));
+        std::string lowerCaseContentType = stringToLowerCase(header.contentType);
         // Checking the HTML content type to see if the URL is a playlist.
-        if (contentType.find(M3U_CONTENT_TYPE) != std::string::npos) {
+        if (lowerCaseContentType.find(M3U_CONTENT_TYPE) != std::string::npos) {
             std::string playlistContent;
-            if (!getPlaylistContent(m_contentFetcherFactory->create(playlistURL), &playlistContent)) {
+            auto contentFetcher = m_contentFetcherFactory->create(playlistURL);
+            contentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
+            if (!readFromContentFetcher(std::move(contentFetcher), &playlistContent, &m_abort)) {
                 ACSDK_ERROR(LX("nextFailed").d("reason", "failedToRetrieveContent").sensitive("url", playlistURL));
                 return PlaylistEntry::createErrorEntry(playlistURL);
             }
@@ -187,10 +186,12 @@ PlaylistEntry IterativePlaylistParser::next() {
                     m_playQueue.push_front(*reverseIt);
                 }
             }
-        } else if (contentType.find(PLS_CONTENT_TYPE) != std::string::npos) {
+        } else if (lowerCaseContentType.find(PLS_CONTENT_TYPE) != std::string::npos) {
             ACSDK_DEBUG9(LX("isPLSPlaylist").sensitive("url", playlistURL));
             std::string playlistContent;
-            if (!getPlaylistContent(m_contentFetcherFactory->create(playlistURL), &playlistContent)) {
+            auto contentFetcher = m_contentFetcherFactory->create(playlistURL);
+            contentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
+            if (!readFromContentFetcher(std::move(contentFetcher), &playlistContent, &m_abort)) {
                 ACSDK_ERROR(LX("nextFailed").d("reason", "failedToRetrieveContent").sensitive("url", playlistURL));
                 return PlaylistEntry::createErrorEntry(playlistURL);
             }
@@ -215,30 +216,6 @@ PlaylistEntry IterativePlaylistParser::next() {
     return PlaylistEntry::createErrorEntry("");
 }
 
-bool IterativePlaylistParser::getPlaylistContent(
-    std::unique_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher,
-    std::string* content) {
-    if (!contentFetcher) {
-        ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "nullContentFetcher"));
-        return false;
-    }
-
-    auto httpContent =
-        contentFetcher->getContent(avsCommon::sdkInterfaces::HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
-    if (!httpContent) {
-        ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "nullHTTPContentReceived"));
-        return false;
-    }
-    do {
-        if (m_abort) {
-            ACSDK_DEBUG9(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "abortParsing"));
-            return false;
-        }
-    } while (!httpContent->isReady(WAIT_FOR_FUTURE_READY_TIMEOUT));
-
-    return extractPlaylistContent(std::move(httpContent), content);
-}
-
 void IterativePlaylistParser::abort() {
     m_abort = true;
 }
diff --git a/PlaylistParser/src/PlaylistParser.cpp b/PlaylistParser/src/PlaylistParser.cpp
index cb5e685..fc0fc81 100644
--- a/PlaylistParser/src/PlaylistParser.cpp
+++ b/PlaylistParser/src/PlaylistParser.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 
 #include <AVSCommon/Utils/Logger/Logger.h>
 #include <AVSCommon/Utils/PlaylistParser/PlaylistParserObserverInterface.h>
+#include <AVSCommon/Utils/String/StringUtils.h>
 
 #include "PlaylistParser/M3UParser.h"
 #include "PlaylistParser/PlaylistParser.h"
@@ -27,7 +28,11 @@
 namespace alexaClientSDK {
 namespace playlistParser {
 
+using namespace alexaClientSDK::avsCommon;
+using namespace avsCommon::avs::attachment;
+using namespace avsCommon::sdkInterfaces;
 using namespace avsCommon::utils::playlistParser;
+using namespace avsCommon::utils::string;
 
 /// String to identify log entries originating from this file.
 static const std::string TAG("PlaylistParser");
@@ -52,7 +57,7 @@ static int g_id = 0;
 static const auto INVALID_DURATION = std::chrono::milliseconds(-1);
 
 std::unique_ptr<PlaylistParser> PlaylistParser::create(
-    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory) {
+    std::shared_ptr<HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory) {
     if (!contentFetcherFactory) {
         return nullptr;
     }
@@ -80,8 +85,7 @@ int PlaylistParser::parsePlaylist(
     return id;
 }
 
-PlaylistParser::PlaylistParser(
-    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory) :
+PlaylistParser::PlaylistParser(std::shared_ptr<HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory) :
         RequiresShutdown{"PlaylistParser"},
         m_contentFetcherFactory{contentFetcherFactory},
         m_shuttingDown{false} {
@@ -101,44 +105,48 @@ void PlaylistParser::doDepthFirstSearch(
     playQueue.push_front(rootUrl);
     std::string lastUrlParsed;
     while (!playQueue.empty() && !m_shuttingDown) {
+        if (m_shuttingDown) {
+            return;
+        }
+
         auto playItem = playQueue.front();
         playQueue.pop_front();
         if (playItem.type == PlayItem::Type::MEDIA_INFO) {
             // This is a media URL and not a playlist
-            ACSDK_DEBUG9(LX("foundNonPlaylistURL"));
+            ACSDK_DEBUG9(LX(__func__).m("foundNonPlaylistURL"));
             observer->onPlaylistEntryParsed(id, playItem.playlistEntry);
             continue;
         }
+
         auto playlistURL = playItem.playlistURL;
         auto contentFetcher = m_contentFetcherFactory->create(playlistURL);
-        auto httpContent = contentFetcher->getContent(
-            avsCommon::sdkInterfaces::HTTPContentFetcherInterface::FetchOptions::CONTENT_TYPE);
-        if (!httpContent) {
-            ACSDK_ERROR(LX("doDepthFirstSearchFailed").d("reason", "nullHTTPContentReceived"));
+
+        contentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
+
+        HTTPContentFetcherInterface::Header header = contentFetcher->getHeader(&m_shuttingDown);
+        if (!header.successful) {
+            ACSDK_ERROR(LX(__func__).sensitive("url", playlistURL).m("getHeaderFailed"));
             observer->onPlaylistEntryParsed(id, PlaylistEntry::createErrorEntry(playlistURL));
             return;
         }
-        do {
-            if (m_shuttingDown) {
-                ACSDK_DEBUG9(LX("doDepthFirstSearch").d("info", "shuttingDown"));
-                return;
-            }
-        } while (!httpContent->isReady(WAIT_FOR_FUTURE_READY_TIMEOUT));
-        if (!httpContent->isStatusCodeSuccess()) {
-            ACSDK_ERROR(LX("doDepthFirstSearchFailed")
-                            .d("reason", "badHTTPContentReceived")
-                            .d("statusCode", httpContent->getStatusCode()));
+
+        if (!isStatusCodeSuccess(header.responseCode)) {
+            ACSDK_DEBUG0(LX("nonSuccessStatusCodeFromGetHeader").d("statusCode", header.responseCode));
             observer->onPlaylistEntryParsed(id, PlaylistEntry::createErrorEntry(playlistURL));
             return;
         }
 
-        std::string contentType = httpContent->getContentType();
-        ACSDK_DEBUG9(LX("gotContentType").d("contentType", contentType).sensitive("url", playlistURL));
-        std::transform(contentType.begin(), contentType.end(), contentType.begin(), ::tolower);
-        // Checking the HTML content type to see if the URL is a playlist.
-        if (contentType.find(M3U_CONTENT_TYPE) != std::string::npos) {
+        ACSDK_DEBUG9(LX("gotHeader")
+                         .d("contentType", header.contentType)
+                         .d("statusCode", header.responseCode)
+                         .m("headersReceived")
+                         .sensitive("url", playlistURL));
+
+        std::string lowerCaseContentType = stringToLowerCase(header.contentType);
+        // Checking the HTTP content type to see if the URL is a playlist.
+        if (lowerCaseContentType.find(M3U_CONTENT_TYPE) != std::string::npos) {
             std::string playlistContent;
-            if (!getPlaylistContent(m_contentFetcherFactory->create(playlistURL), &playlistContent)) {
+            if (!playlistParser::readFromContentFetcher(std::move(contentFetcher), &playlistContent, &m_shuttingDown)) {
                 ACSDK_ERROR(LX("failedToRetrieveContent").sensitive("url", playlistURL));
                 observer->onPlaylistEntryParsed(id, PlaylistEntry::createErrorEntry(playlistURL));
                 return;
@@ -185,7 +193,7 @@ void PlaylistParser::doDepthFirstSearch(
                         }
                         lastUrlParsed = entries.back().url;
                     } else {
-                        // Setting this to 0 as an intial value so that if we don't see the last URL we parsed in the
+                        // Setting this to 0 as an initial value so that if we don't see the last URL we parsed in the
                         // latest pass of the playlist, we stream all the URLs within the playlist as a sort of
                         // recovery mechanism. This way, if we parse this so far into the future that all the URLs we
                         // had previously seen are gone, we'll still stream the latest URLs.
@@ -220,7 +228,7 @@ void PlaylistParser::doDepthFirstSearch(
                     playQueue.push_front(reverseIt->url);
                 }
             }
-        } else if (contentType.find(PLS_CONTENT_TYPE) != std::string::npos) {
+        } else if (lowerCaseContentType.find(PLS_CONTENT_TYPE) != std::string::npos) {
             ACSDK_DEBUG9(LX("isPLSPlaylist").sensitive("url", playlistURL));
             /*
              * This is for sure a PLS playlist, so if PLS is one of the desired playlist types to not be parsed, then
@@ -234,7 +242,7 @@ void PlaylistParser::doDepthFirstSearch(
                 continue;
             }
             std::string playlistContent;
-            if (!getPlaylistContent(m_contentFetcherFactory->create(playlistURL), &playlistContent)) {
+            if (!playlistParser::readFromContentFetcher(std::move(contentFetcher), &playlistContent, &m_shuttingDown)) {
                 observer->onPlaylistEntryParsed(id, PlaylistEntry::createErrorEntry(playlistURL));
                 return;
             }
@@ -247,40 +255,28 @@ void PlaylistParser::doDepthFirstSearch(
                 playQueue.push_front(*reverseIt);
             }
         } else {
+            // AUDIO CONTENT
             ACSDK_DEBUG9(LX("foundNonPlaylistURL"));
             // This is a non-playlist URL or a playlist that we don't support (M3U, EXT_M3U, PLS).
             auto parseResult = playQueue.empty() ? PlaylistParseResult::FINISHED : PlaylistParseResult::STILL_ONGOING;
-            observer->onPlaylistEntryParsed(id, PlaylistEntry(playlistURL, INVALID_DURATION, parseResult));
+            observer->onPlaylistEntryParsed(
+                id,
+                PlaylistEntry(
+                    playlistURL,
+                    INVALID_DURATION,
+                    parseResult,
+                    PlaylistEntry::Type::AUDIO_CONTENT,
+                    std::make_tuple(0, 0),
+                    EncryptionInfo(),
+                    std::move(contentFetcher)));
         }
     }
-}
-
-bool PlaylistParser::getPlaylistContent(
-    std::unique_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher,
-    std::string* content) {
-    if (!contentFetcher) {
-        ACSDK_ERROR(LX("getPlaylistContentFailed").d("reason", "nullContentFetcher"));
-        return false;
+    if (playQueue.empty()) {
+        ACSDK_DEBUG9(LX("playQueueEmpty"));
     }
-
-    if (!content) {
-        ACSDK_ERROR(LX("getPlaylistContentFailed").d("reason", "nullString"));
-        return false;
+    if (m_shuttingDown) {
+        ACSDK_DEBUG9(LX("shuttingDown"));
     }
-    auto httpContent =
-        contentFetcher->getContent(avsCommon::sdkInterfaces::HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
-    if (!httpContent) {
-        ACSDK_ERROR(LX("getPlaylistContentFailed").d("reason", "nullHTTPContentReceived"));
-        return false;
-    }
-    do {
-        if (m_shuttingDown) {
-            ACSDK_DEBUG9(LX("getPlaylistContentFailed").d("info", "shuttingDown"));
-            return false;
-        }
-    } while (!httpContent->isReady(WAIT_FOR_FUTURE_READY_TIMEOUT));
-
-    return extractPlaylistContent(std::move(httpContent), content);
 }
 
 void PlaylistParser::doShutdown() {
diff --git a/PlaylistParser/src/PlaylistUtils.cpp b/PlaylistParser/src/PlaylistUtils.cpp
index dd6bc46..05034d0 100644
--- a/PlaylistParser/src/PlaylistUtils.cpp
+++ b/PlaylistParser/src/PlaylistUtils.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -25,6 +25,11 @@
 namespace alexaClientSDK {
 namespace playlistParser {
 
+using namespace avsCommon::avs::attachment;
+using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::utils::http;
+using namespace avsCommon::utils::sds;
+
 /// String to identify log entries originating from this file.
 static const std::string TAG("PlaylistUtils");
 
@@ -38,68 +43,131 @@ static const std::string TAG("PlaylistUtils");
 /// The number of bytes read from the attachment with each read in the read loop.
 static const size_t CHUNK_SIZE(1024);
 
-/// The first line of a PLS playlist.
-static const std::string PLS_PLAYLIST_HEADER = "[playlist]";
-
 /// The beginning of a line in a PLS file indicating a URL.
 static const std::string PLS_FILE = "File";
 
 /// url scheme pattern.
 static const std::string URL_END_SCHEME_PATTERN = "://";
 
-bool extractPlaylistContent(std::unique_ptr<avsCommon::utils::HTTPContent> httpContent, std::string* content) {
+/// A wait period for a polling loop that constantly check if a content fetcher finished fetching the payload or failed.
+static const std::chrono::milliseconds WAIT_FOR_ACTIVITY_TIMEOUT{100};
+
+/// Process attachment ID
+static const std::string PROCESS_ATTACHMENT_ID = "download:";
+
+/// Timeout to wait for a playlist to arrive from the content fetcher
+static const std::chrono::minutes PLAYLIST_FETCH_TIMEOUT{5};
+
+bool readFromContentFetcher(
+    std::unique_ptr<HTTPContentFetcherInterface> contentFetcher,
+    std::string* content,
+    std::atomic<bool>* shouldShutDown) {
+    ACSDK_DEBUG9(LX(__func__));
+    if (!contentFetcher) {
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "nullContentFetcher"));
+        return false;
+    }
+
     if (!content) {
-        ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "nullString"));
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "nullContent"));
+        return false;
+    }
+
+    if (*shouldShutDown) {
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "shouldShutdown"));
+        return false;
+    }
+
+    auto header = contentFetcher->getHeader(shouldShutDown);
+    if (!header.successful) {
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "getHeaderFailed"));
+        return false;
+    }
+
+    if (!isStatusCodeSuccess(header.responseCode)) {
+        ACSDK_WARN(LX("readFromContentFetcherFailed")
+                       .d("reason", "failedToReceiveHeader")
+                       .d("statusCode", header.responseCode));
         return false;
     }
-    if (!httpContent) {
-        ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "nullHTTPContentReceived"));
+
+    auto stream = std::make_shared<InProcessAttachment>(PROCESS_ATTACHMENT_ID);
+    std::shared_ptr<AttachmentWriter> streamWriter = stream->createWriter(WriterPolicy::BLOCKING);
+
+    if (!contentFetcher->getBody(streamWriter)) {
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "getBodyFailed"));
         return false;
     }
-    if (!httpContent->isStatusCodeSuccess()) {
-        ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed")
-                        .d("reason", "badHTTPContentReceived")
-                        .d("statusCode", httpContent->getStatusCode()));
+
+    auto startTime = std::chrono::steady_clock::now();
+    auto elapsedTime = std::chrono::steady_clock::now() - startTime;
+    HTTPContentFetcherInterface::State contentFetcherState = contentFetcher->getState();
+    while ((PLAYLIST_FETCH_TIMEOUT > elapsedTime) &&
+           (HTTPContentFetcherInterface::State::BODY_DONE != contentFetcherState) &&
+           (HTTPContentFetcherInterface::State::ERROR != contentFetcherState)) {
+        std::this_thread::sleep_for(WAIT_FOR_ACTIVITY_TIMEOUT);
+        if (*shouldShutDown) {
+            return false;
+        }
+        elapsedTime = std::chrono::steady_clock::now() - startTime;
+        contentFetcherState = contentFetcher->getState();
+    }
+    if (PLAYLIST_FETCH_TIMEOUT <= elapsedTime) {
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "waitTimeout"));
         return false;
     }
 
-    auto reader = httpContent->getDataStream()->createReader(avsCommon::utils::sds::ReaderPolicy::BLOCKING);
-    if (!reader) {
-        ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "failedToCreateStreamReader"));
+    if (HTTPContentFetcherInterface::State::ERROR == contentFetcherState) {
+        ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "receivingBodyFailed"));
         return false;
     }
-    avsCommon::avs::attachment::AttachmentReader::ReadStatus readStatus =
-        avsCommon::avs::attachment::AttachmentReader::ReadStatus::OK;
-    std::string playlistContent;
+
+    ACSDK_DEBUG9(LX("bodyReceived"));
+
+    std::unique_ptr<AttachmentReader> reader = stream->createReader(ReaderPolicy::NONBLOCKING);
+
+    auto readStatus = AttachmentReader::ReadStatus::OK;
     std::vector<char> buffer(CHUNK_SIZE, 0);
     bool streamClosed = false;
-    while (!streamClosed) {
-        auto bytesRead = reader->read(buffer.data(), buffer.size(), &readStatus);
+    AttachmentReader::ReadStatus previousStatus = AttachmentReader::ReadStatus::OK_TIMEDOUT;
+    ssize_t bytesReadSoFar = 0;
+    size_t bytesRead = -1;
+    while (!streamClosed && bytesRead != 0) {
+        bytesRead = reader->read(buffer.data(), buffer.size(), &readStatus);
+        bytesReadSoFar += bytesRead;
+        if (previousStatus != readStatus) {
+            ACSDK_DEBUG9(LX(__func__).d("readStatus", readStatus));
+            previousStatus = readStatus;
+        }
         switch (readStatus) {
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::CLOSED:
+            case AttachmentReader::ReadStatus::CLOSED:
                 streamClosed = true;
                 if (bytesRead == 0) {
                     break;
                 }
-            /* FALL THROUGH - to add any data received even if closed */
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::OK:
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::OK_WOULDBLOCK:
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::OK_TIMEDOUT:
-                playlistContent.append(buffer.data(), bytesRead);
+                /* FALL THROUGH - to add any data received even if closed */
+            case AttachmentReader::ReadStatus::OK:
+            case AttachmentReader::ReadStatus::OK_WOULDBLOCK:
+            case AttachmentReader::ReadStatus::OK_TIMEDOUT:
+                content->append(buffer.data(), bytesRead);
                 break;
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::OK_OVERRUN_RESET:
+            case AttachmentReader::ReadStatus::OK_OVERRUN_RESET:
                 // Current AttachmentReader policy renders this outcome impossible.
-                ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("failure", "overrunReset"));
+                ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "overrunReset"));
                 break;
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::ERROR_OVERRUN:
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::ERROR_BYTES_LESS_THAN_WORD_SIZE:
-            case avsCommon::avs::attachment::AttachmentReader::ReadStatus::ERROR_INTERNAL:
-                ACSDK_ERROR(LX("getContentFromPlaylistUrlIntoStringFailed").d("reason", "readError"));
+            case AttachmentReader::ReadStatus::ERROR_OVERRUN:
+            case AttachmentReader::ReadStatus::ERROR_BYTES_LESS_THAN_WORD_SIZE:
+            case AttachmentReader::ReadStatus::ERROR_INTERNAL:
+                ACSDK_ERROR(LX("readFromContentFetcherFailed").d("reason", "readError"));
                 return false;
         }
+        if (0 == bytesRead) {
+            ACSDK_DEBUG9(LX(__func__).m("alreadyReadAllBytes"));
+        }
     }
-    *content = playlistContent;
-    return true;
+
+    ACSDK_DEBUG9(LX("readFromContentFetcherDone").d("URL", contentFetcher->getUrl()).d("content", *content));
+    return !(*content).empty();
 }
 
 std::vector<std::string> parsePLSContent(const std::string& playlistURL, const std::string& content) {
diff --git a/PlaylistParser/src/UrlContentToAttachmentConverter.cpp b/PlaylistParser/src/UrlContentToAttachmentConverter.cpp
index 75274c2..4670433 100644
--- a/PlaylistParser/src/UrlContentToAttachmentConverter.cpp
+++ b/PlaylistParser/src/UrlContentToAttachmentConverter.cpp
@@ -38,12 +38,12 @@ static const std::string TAG("UrlContentToAttachmentConverter");
 /// An invalid duration.
 static const std::chrono::milliseconds INVALID_DURATION = std::chrono::milliseconds(-1);
 
-/// Timeout for future ready.
-static const std::chrono::milliseconds WAIT_FOR_FUTURE_READY_TIMEOUT(100);
-
 /// The number of bytes read from the attachment with each read in the read loop.
 static const size_t CHUNK_SIZE(1024);
 
+/// Timeout for polling loops that check activities running on separate threads.
+static const std::chrono::milliseconds WAIT_FOR_ACTIVITY_TIMEOUT{100};
+
 std::shared_ptr<UrlContentToAttachmentConverter> UrlContentToAttachmentConverter::create(
     std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterfaceFactoryInterface> contentFetcherFactory,
     const std::string& url,
@@ -111,9 +111,9 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
     // Download and cache Media Initialization Section for SAMPLE-AES content.
     if (playlistEntry.type == PlaylistEntry::Type::MEDIA_INIT_INFO &&
         encryptionInfo.method == EncryptionInfo::Method::SAMPLE_AES) {
-        m_executor.submit([this, url, headers]() {
+        m_executor.submit([this, url, headers, playlistEntry]() {
             ByteVector mediaInitSection;
-            if (!download(url, headers, &mediaInitSection)) {
+            if (!download(url, headers, &mediaInitSection, playlistEntry.contentFetcher)) {
                 closeStreamWriter();
                 notifyError();
                 return;
@@ -121,6 +121,8 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
             m_contentDecrypter->writeMediaInitSection(mediaInitSection);
         });
         return;
+    } else if (PlaylistEntry::Type::AUDIO_CONTENT == playlistEntry.type) {
+        ACSDK_DEBUG3(LX("foundAudioContent"));
     }
 
     if (!m_startedStreaming) {
@@ -142,6 +144,7 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
     }
     m_startedStreaming = true;
     ACSDK_DEBUG3(LX("onPlaylistEntryParsed").d("status", parseResult));
+    auto contentFetcher = playlistEntry.contentFetcher;
     switch (parseResult) {
         case avsCommon::utils::playlistParser::PlaylistParseResult::ERROR:
             m_executor.submit([this]() {
@@ -151,8 +154,10 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
             });
             break;
         case avsCommon::utils::playlistParser::PlaylistParseResult::FINISHED:
-            m_executor.submit([this, url, headers, encryptionInfo]() {
-                if (!m_streamWriterClosed && !writeDecryptedUrlContentIntoStream(url, headers, encryptionInfo)) {
+            m_executor.submit([this, url, headers, encryptionInfo, contentFetcher]() {
+                ACSDK_DEBUG9(LX("calling writeDecryptedUrlContentIntoStream"));
+                if (!m_streamWriterClosed &&
+                    !writeDecryptedUrlContentIntoStream(url, headers, encryptionInfo, contentFetcher)) {
                     ACSDK_ERROR(LX("writeUrlContentToStreamFailed"));
                     notifyError();
                 }
@@ -161,8 +166,9 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
             });
             break;
         case avsCommon::utils::playlistParser::PlaylistParseResult::STILL_ONGOING:
-            m_executor.submit([this, url, headers, encryptionInfo]() {
-                if (!m_streamWriterClosed && !writeDecryptedUrlContentIntoStream(url, headers, encryptionInfo)) {
+            m_executor.submit([this, url, headers, encryptionInfo, contentFetcher]() {
+                if (!m_streamWriterClosed &&
+                    !writeDecryptedUrlContentIntoStream(url, headers, encryptionInfo, contentFetcher)) {
                     ACSDK_ERROR(LX("writeUrlContentToStreamFailed").d("info", "closingWriter"));
                     closeStreamWriter();
                     notifyError();
@@ -175,6 +181,7 @@ void UrlContentToAttachmentConverter::onPlaylistEntryParsed(int requestId, Playl
 }
 
 void UrlContentToAttachmentConverter::closeStreamWriter() {
+    ACSDK_DEBUG(LX(__func__));
     m_streamWriter->close();
     m_streamWriterClosed = true;
 }
@@ -191,19 +198,20 @@ void UrlContentToAttachmentConverter::notifyError() {
 bool UrlContentToAttachmentConverter::writeDecryptedUrlContentIntoStream(
     std::string url,
     std::vector<std::string> headers,
-    EncryptionInfo encryptionInfo) {
+    EncryptionInfo encryptionInfo,
+    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher) {
     ACSDK_DEBUG9(LX("writeDecryptedUrlContentIntoStream").d("info", "beginning"));
 
     auto hasValidEncryption = shouldDecrypt(encryptionInfo);
     if (hasValidEncryption) {
         ByteVector content;
-        if (!download(url, headers, &content)) {
+        if (!download(url, headers, &content, contentFetcher)) {
             ACSDK_ERROR(LX("writeDecryptedUrlContentIntoStreamFailed").d("reason", "downloadContentFailed"));
             return false;
         }
 
         ByteVector key;
-        if (!download(encryptionInfo.keyURL, std::vector<std::string>(), &key)) {
+        if (!download(encryptionInfo.keyURL, std::vector<std::string>(), &key, contentFetcher)) {
             ACSDK_ERROR(LX("writeDecryptedUrlContentIntoStreamFailed").d("reason", "downloadEncryptionKeyFailed"));
             return false;
         }
@@ -213,7 +221,7 @@ bool UrlContentToAttachmentConverter::writeDecryptedUrlContentIntoStream(
             return false;
         }
     } else {
-        if (!download(url, headers, m_streamWriter)) {
+        if (!download(url, headers, m_streamWriter, contentFetcher)) {
             ACSDK_ERROR(LX("writeDecryptedUrlContentIntoStreamFailed").d("reason", "downloadFailed"));
             return false;
         }
@@ -230,10 +238,11 @@ bool UrlContentToAttachmentConverter::shouldDecrypt(const EncryptionInfo& encryp
 bool UrlContentToAttachmentConverter::download(
     const std::string& url,
     const std::vector<std::string>& headers,
-    ByteVector* content) {
+    ByteVector* content,
+    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher) {
     auto stream = std::make_shared<InProcessAttachment>("download:" + url);
     std::shared_ptr<AttachmentWriter> streamWriter = stream->createWriter(WriterPolicy::BLOCKING);
-    if (!download(url, headers, streamWriter)) {
+    if (!download(url, headers, streamWriter, contentFetcher)) {
         ACSDK_ERROR(LX("downloadFailed").d("reason", "downloadToStreamFailed"));
         return false;
     }
@@ -294,36 +303,47 @@ bool UrlContentToAttachmentConverter::readContent(std::shared_ptr<AttachmentRead
 bool UrlContentToAttachmentConverter::download(
     const std::string& url,
     const std::vector<std::string>& headers,
-    std::shared_ptr<AttachmentWriter> streamWriter) {
+    std::shared_ptr<AttachmentWriter> streamWriter,
+    std::shared_ptr<avsCommon::sdkInterfaces::HTTPContentFetcherInterface> contentFetcher) {
     if (!streamWriter) {
         ACSDK_ERROR(LX("downloadFailed").d("reason", "nullStreamWriter"));
         return false;
     }
 
-    auto contentFetcher = m_contentFetcherFactory->create(url);
-    auto httpContent =
-        contentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY, streamWriter, headers);
-    if (!httpContent) {
-        ACSDK_ERROR(LX("getContentFailed").d("reason", "nullHTTPContentReceived"));
-        return false;
+    std::shared_ptr<HTTPContentFetcherInterface> localContentFetcher;
+
+    if (contentFetcher) {
+        ACSDK_DEBUG9(LX("usingExistingContentFetcher"));
+        localContentFetcher = contentFetcher;
+    } else {
+        ACSDK_DEBUG9(LX("usingNewContentFetcher"));
+
+        localContentFetcher = m_contentFetcherFactory->create(url);
+
+        localContentFetcher->getContent(HTTPContentFetcherInterface::FetchOptions::ENTIRE_BODY);
+
+        HTTPContentFetcherInterface::Header header = localContentFetcher->getHeader(&m_shuttingDown);
+
+        if (!header.successful) {
+            return false;
+        }
     }
 
-    do {
+    localContentFetcher->getBody(streamWriter);
+
+    while (localContentFetcher->getState() == HTTPContentFetcherInterface::State::FETCHING_BODY) {
         if (m_shuttingDown) {
             ACSDK_DEBUG9(LX("writeDecryptedUrlContentIntoStream").d("info", "shuttingDown"));
             return true;
         }
-    } while (!httpContent->isReady(WAIT_FOR_FUTURE_READY_TIMEOUT));
-
-    if (!httpContent->isStatusCodeSuccess()) {
-        ACSDK_ERROR(
-            LX("getContentFailed").d("reason", "badHTTPContentReceived").d("statusCode", httpContent->getStatusCode()));
-        return false;
+        std::this_thread::sleep_for(WAIT_FOR_ACTIVITY_TIMEOUT);
     }
+
     return true;
 }
 
 void UrlContentToAttachmentConverter::doShutdown() {
+    ACSDK_DEBUG9(LX(__func__).m("Starting to shutdown"));
     {
         std::lock_guard<std::mutex> lock{m_mutex};
         m_observer.reset();
diff --git a/PlaylistParser/test/PlaylistParser/MockContentFetcher.h b/PlaylistParser/test/PlaylistParser/MockContentFetcher.h
index 5e2817c..4b87874 100644
--- a/PlaylistParser/test/PlaylistParser/MockContentFetcher.h
+++ b/PlaylistParser/test/PlaylistParser/MockContentFetcher.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -25,11 +25,10 @@ namespace alexaClientSDK {
 namespace playlistParser {
 namespace test {
 
-/// HTTP OK response code which indicates that the request has succeeded.
-static const int HTTP_REQUEST_OK = 200;
+using namespace avsCommon::sdkInterfaces;
 
 /// Short time out for when callbacks are expected not to occur.
-static const auto SHORT_TIMEOUT = std::chrono::milliseconds(50);
+static const auto SHORT_TIMEOUT = std::chrono::milliseconds(100);
 
 /// Test M3U url.
 static const std::string TEST_M3U_PLAYLIST_URL{"http://sanjayisthecoolest.com/sample.m3u"};
@@ -222,69 +221,79 @@ static std::unordered_map<std::string, std::string> urlsToContent{
     {TEST_HLS_LIVE_STREAM_PLAYLIST_URL, TEST_HLS_LIVE_STREAM_PLAYLIST_CONTENT_1}};
 
 /// A mock content fetcher
-class MockContentFetcher : public avsCommon::sdkInterfaces::HTTPContentFetcherInterface {
+class MockContentFetcher : public HTTPContentFetcherInterface {
 public:
-    MockContentFetcher(const std::string& url) : m_url{url} {
+    MockContentFetcher(const std::string& url) : m_url{url}, m_state{HTTPContentFetcherInterface::State::INITIALIZED} {
     }
 
-    std::unique_ptr<avsCommon::utils::HTTPContent> getContent(
-        FetchOptions fetchOption,
-        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer,
-        const std::vector<std::string>& customHeaders = std::vector<std::string>()) {
-        if (fetchOption == FetchOptions::CONTENT_TYPE) {
-            auto it1 = urlsToContentTypes.find(m_url);
-            if (it1 == urlsToContentTypes.end()) {
-                return nullptr;
-            } else {
-                std::promise<long> statusPromise;
-                auto statusFuture = statusPromise.get_future();
-                statusPromise.set_value(HTTP_REQUEST_OK);
-                std::promise<std::string> contentTypePromise;
-                auto contentTypeFuture = contentTypePromise.get_future();
-                contentTypePromise.set_value(it1->second);
-                return avsCommon::utils::memory::make_unique<avsCommon::utils::HTTPContent>(
-                    std::move(statusFuture), std::move(contentTypeFuture), nullptr);
-            }
-        } else if (fetchOption == FetchOptions::ENTIRE_BODY) {
-            auto it2 = urlsToContent.find(m_url);
-            if (it2 == urlsToContent.end()) {
-                return nullptr;
-            } else {
-                static bool liveStreamPlaylistRequested = false;
-                if (m_url == TEST_HLS_LIVE_STREAM_PLAYLIST_URL) {
-                    if (!liveStreamPlaylistRequested) {
-                        it2->second = TEST_HLS_LIVE_STREAM_PLAYLIST_CONTENT_1;
-                        liveStreamPlaylistRequested = true;
-                    } else {
-                        it2->second = TEST_HLS_LIVE_STREAM_PLAYLIST_CONTENT_2;
-                    }
+    std::string getUrl() const override {
+        return m_url;
+    }
+
+    HTTPContentFetcherInterface::Header getHeader(std::atomic<bool>* shouldShutdown) override {
+        HTTPContentFetcherInterface::Header header;
+        auto it1 = urlsToContentTypes.find(m_url);
+        if (it1 == urlsToContentTypes.end()) {
+            header.successful = false;
+        } else {
+            header.successful = true;
+            header.responseCode = avsCommon::utils::http::HTTPResponseCode::SUCCESS_OK;
+            header.contentType = it1->second;
+            m_state = HTTPContentFetcherInterface::State::HEADER_DONE;
+        }
+        return header;
+    }
+
+    HTTPContentFetcherInterface::State getState() override {
+        return m_state;
+    }
+
+    bool getBody(std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer) override {
+        auto it2 = urlsToContent.find(m_url);
+        if (it2 == urlsToContent.end()) {
+            return false;
+        } else {
+            static bool liveStreamPlaylistRequested = false;
+            if (m_url == TEST_HLS_LIVE_STREAM_PLAYLIST_URL) {
+                if (!liveStreamPlaylistRequested) {
+                    it2->second = TEST_HLS_LIVE_STREAM_PLAYLIST_CONTENT_1;
+                    liveStreamPlaylistRequested = true;
+                } else {
+                    it2->second = TEST_HLS_LIVE_STREAM_PLAYLIST_CONTENT_2;
                 }
-                std::promise<long> statusPromise;
-                auto statusFuture = statusPromise.get_future();
-                statusPromise.set_value(HTTP_REQUEST_OK);
-                std::promise<std::string> contentTypePromise;
-                auto contentTypeFuture = contentTypePromise.get_future();
-                contentTypePromise.set_value("");
-                return avsCommon::utils::memory::make_unique<avsCommon::utils::HTTPContent>(
-                    std::move(statusFuture), std::move(contentTypeFuture), writeStringIntoAttachment(it2->second));
             }
-        } else {
-            return nullptr;
+            auto attachment = writeStringIntoAttachment(it2->second, std::move(writer));
+            if (!attachment) {
+                return false;
+            }
+            m_state = HTTPContentFetcherInterface::State::BODY_DONE;
         }
+        return true;
+    }
+
+    void shutdown() override {
+    }
+
+    std::unique_ptr<avsCommon::utils::HTTPContent> getContent(
+        FetchOptions fetchOption,
+        std::unique_ptr<avsCommon::avs::attachment::AttachmentWriter> writer,
+        const std::vector<std::string>& customHeaders = std::vector<std::string>()) override {
+        return nullptr;
     }
 
 private:
     std::shared_ptr<avsCommon::avs::attachment::InProcessAttachment> writeStringIntoAttachment(
-        const std::string& string) {
+        const std::string& string,
+        std::shared_ptr<avsCommon::avs::attachment::AttachmentWriter> writer) {
         static int id = 0;
         std::shared_ptr<avsCommon::avs::attachment::InProcessAttachment> stream =
             std::make_shared<avsCommon::avs::attachment::InProcessAttachment>(std::to_string(id++));
         if (!stream) {
             return nullptr;
         }
-        auto writer = stream->createWriter();
+
         if (!writer) {
-            return nullptr;
+            writer = stream->createWriter();
         }
         avsCommon::avs::attachment::AttachmentWriter::WriteStatus writeStatus;
         writer->write(string.data(), string.size(), &writeStatus);
@@ -292,6 +301,8 @@ private:
     };
 
     std::string m_url;
+
+    HTTPContentFetcherInterface::State m_state;
 };
 
 }  // namespace test
diff --git a/SampleApp/Authorization/CBLAuthDelegate/src/CBLAuthDelegate.cpp b/SampleApp/Authorization/CBLAuthDelegate/src/CBLAuthDelegate.cpp
index 2f16778..2bfbc20 100644
--- a/SampleApp/Authorization/CBLAuthDelegate/src/CBLAuthDelegate.cpp
+++ b/SampleApp/Authorization/CBLAuthDelegate/src/CBLAuthDelegate.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -27,8 +27,8 @@
 
 #include <AVSCommon/AVS/Initialization/AlexaClientSDKInit.h>
 #include <AVSCommon/Utils/DeviceInfo.h>
+#include <AVSCommon/Utils/HTTP/HttpResponseCode.h>
 #include <AVSCommon/Utils/LibcurlUtils/HttpPost.h>
-#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
 #include "CBLAuthDelegate/CBLAuthDelegate.h"
@@ -38,6 +38,7 @@ namespace authorization {
 namespace cblAuthDelegate {
 
 using namespace alexaClientSDK::avsCommon::sdkInterfaces;
+using namespace alexaClientSDK::avsCommon::utils::http;
 using namespace alexaClientSDK::avsCommon::utils::libcurlUtils;
 using namespace alexaClientSDK::registrationManager;
 using namespace rapidjson;
@@ -204,11 +205,11 @@ static AuthObserverInterface::Error mapHTTPCodeToError(long code) {
             error = AuthObserverInterface::Error::SUCCESS;
             break;
 
-        case HTTPResponseCode::BAD_REQUEST:
+        case HTTPResponseCode::CLIENT_ERROR_BAD_REQUEST:
             error = AuthObserverInterface::Error::INVALID_REQUEST;
             break;
 
-        case HTTPResponseCode::SERVER_INTERNAL_ERROR:
+        case HTTPResponseCode::SERVER_ERROR_INTERNAL:
             error = AuthObserverInterface::Error::SERVER_ERROR;
             break;
 
diff --git a/SampleApp/Authorization/CBLAuthDelegate/src/SQLiteCBLAuthDelegateStorage.cpp b/SampleApp/Authorization/CBLAuthDelegate/src/SQLiteCBLAuthDelegateStorage.cpp
index 51d1c9c..8d7fa65 100644
--- a/SampleApp/Authorization/CBLAuthDelegate/src/SQLiteCBLAuthDelegateStorage.cpp
+++ b/SampleApp/Authorization/CBLAuthDelegate/src/SQLiteCBLAuthDelegateStorage.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -55,7 +55,7 @@ static const std::string CONFIG_KEY_DB_FILE_PATH_KEY = "databaseFilePath";
 
 /// String for creating the refreshToken table
 static const std::string CREATE_REFRESH_TOKEN_TABLE_SQL_STRING =
-    "CREATE TABLE " REFRESH_TOKEN_COLUMN_NAME " (" REFRESH_TOKEN_COLUMN_NAME " TEXT);";
+    "CREATE TABLE " REFRESH_TOKEN_TABLE_NAME " (" REFRESH_TOKEN_COLUMN_NAME " TEXT);";
 
 std::unique_ptr<SQLiteCBLAuthDelegateStorage> SQLiteCBLAuthDelegateStorage::create(
     const avsCommon::utils::configuration::ConfigurationNode& configurationRoot) {
-- 
2.21.0

